{
  "cmd_received": "Run command received",
  "run_file": "Running file",
  "reading_file": "Reading file: {0}",
  "build_bytecode": "Building bytecode",
  "writing_bytecode": "Writing bytecode to: {0}",
  "lex_start": "Starting lexical analysis",
  "lex_complete": "Lexical analysis completed",
  "lex_complete_tokens": "Lexical analysis completed: {0} tokens",
  "lex_token_identifier": "Lexer: identifier {0}",
  "lex_token_keyword": "Lexer: keyword {0}",
  "lex_token_number": "Lexer: number {0}",
  "lex_token_string": "Lexer: string \"{0}\"",
  "lex_token_char": "Lexer: char '{0}'",
  "lex_token_operator": "Lexer: operator {0}",
  "lex_token_punctuation": "Lexer: punctuation {0}",
  "parser_start": "Starting parsing {0} tokens",
  "parser_complete": "Parsing completed",
  "parser_complete_items": "Parsing completed: {0} items",
  "parser_parse_stmt": "Parsing statement: {0}",
  "parser_parse_expr": "Parsing expression",
  "parser_parse_fn_def": "Parsing function definition: {0}",
  "parser_parse_let": "Parsing variable binding: {0}",
  "parser_parse_return": "Parsing return statement",
  "parser_parse_if": "Parsing if statement",
  "parser_parse_loop": "Parsing loop statement",
  "parser_parse_block": "Parsing block",
  "typecheck_start": "Starting type checking",
  "typecheck_complete": "Type checking completed",
  "typecheck_process_fn": "Processing function: {0}",
  "typecheck_has_annotation": "Has type annotation: {0}",
  "typecheck_annotation": "Type annotation: {0}",
  "typecheck_annotated": "Annotated: {0}, untyped params: {1}",
  "typecheck_add_error": "Adding error for param: {0}",
  "typecheck_call_fndef": "Checking function definition",
  "typecheck_infer_expr": "Inferring expression type",
  "typecheck_infer_fn": "Inferring function: {0}",
  "typecheck_add_constraint": "Adding constraint: {0} = {1}",
  "typecheck_solve_constraints": "Solving type constraints",
  "typecheck_var_binding": "Variable binding: {0} : {1}",
  "codegen_start": "Starting code generation",
  "codegen_complete": "Code generation completed",
  "codegen_functions": "Code generation completed: {0} functions",
  "codegen_const_pool": "Generating constant pool: {0} constants",
  "codegen_code_section": "Generating code section: {0} functions",
  "codegen_type_table": "Generating type table: {0} types",
  "codegen_gen_fn": "Generating function: {0}",
  "codegen_gen_block": "Generating basic block",
  "codegen_gen_instr": "Generating instruction: {0}",
  "codegen_reg_alloc": "Allocating register: {0}",
  "codegen_add_const": "Adding constant: {0}",
  "vm_start": "VM starting execution",
  "vm_complete": "VM execution completed",
  "vm_execute_fn": "Executing function: {0}",
  "vm_exec_instruction": "Executing instruction: {0}",
  "vm_call_stack": "Call stack depth: {0}",
  "vm_push_frame": "Pushing frame: {0}",
  "vm_pop_frame": "Popping frame",
  "vm_load_local": "Load local: idx={0}, val={1}",
  "vm_store_local": "Store local: idx={0}, src={1}, registers.len={2}",
  "vm_load_arg": "Load arg: dst={0}, arg_idx={1}, args.len={2}",
  "vm_reg_read": "Read register: r{0} = {1}",
  "vm_reg_write": "Write register: r{0} = {1}",
  "vm_push_stack": "Push stack: {0}",
  "vm_pop_stack": "Pop stack",
  "vm_call_func": "Call function: {0}",
  "vm_return_func": "Function return",
  "vm_binary_op": "Executing BinaryOp {0}",
  "vm_i64_add": "Adding {0} + {1}",
  "vm_executing_function": "Executing function '{0}' with args {1}",
  "vm_function_returned": "Function '{0}' returned {1}",
  "vm_storing_result": "Storing result to register {0}",
  "vm_registers_after": "Registers after storing: {0}",
  "compilation_start": "Starting compilation",
  "compiling_source": "Compiling source code ({0} bytes)",
  "debug_run_called": "run() called",
  "debug_checking_stmt": "Checking statement",
  "debug_stmt_expr": "Statement kind: Expr",
  "debug_stmt_fn": "Statement kind: Fn for {0}",
  "debug_checking_type": "Checking type definition for {0}",
  "debug_struct_type": "Registering struct type '{0}' in scope",
  "debug_non_struct_type": "Registering non-struct type '{0}' in scope",
  "debug_loading_function": "Loading function '{0}' into interpreter",
  "debug_total_functions": "Total functions loaded: {0}",
  "debug_available_functions": "Available functions: {0}",
  "debug_function_lookup": "Looking up function '{0}' (lookup_name: '{1}')",
  "debug_function_found": "Found function '{0}'",
  "debug_function_call": "Calling function '{0}' with args: {1}",
  "debug_function_return": "Function '{0}' returned: {1}",
  "debug_exec_binary_op": "Executing binary operation: lhs={0}, rhs={1}, op={2}",
  "debug_adding_numbers": "Adding {0} + {1}",
  "debug_struct_type_constructor_call": "Detected struct type constructor call for {0}",
  "debug_translating_instr": "Translating instruction: {0}",
  "debug_generating_ir_binop": "Generating IR for BinOp {0}",
  "error_unknown_variable": "Unknown variable: {0}",
  "error_unknown_type": "Unknown type: {0}",
  "error_type_mismatch": "Type mismatch: expected {0}, found {1}",
  "error_arity_mismatch": "Arity mismatch: expected {0} arguments, found {1}",
  "error_index_out_of_bounds": "Index out of bounds: {0} (size: {1})",
  "error_unknown_field": "Unknown field '{0}' in '{1}'",
  "error_recursive_type": "Recursive type definition: {0}",
  "error_unsupported_op": "Unsupported operation: {0}",
  "error_non_exhaustive_patterns": "Non-exhaustive patterns: missing {0} pattern(s)",
  "error_import_error": "Import error: {0}",
  "error_inference_failed": "Inference failed: {0}",
  "error_cannot_infer_param_type": "Cannot infer type for parameter '{0}': parameter has no type annotation and is not used in a way that allows inference",
  "help_did_you_mean": "did you mean {0}?",
  "help_similar_variables": "similar variables: {0}",
  "help_in_scope": "in scope: {0}",

  "bytecode_dump_header": "=== Bytecode Dump for {0} ===",
  "bytecode_dump_type_table": "=== Type Table ({0} types) ===",
  "bytecode_dump_constants": "=== Constants ({0} items) ===",
  "bytecode_dump_functions": "=== Functions ({0} functions) ===",
  "bytecode_file_header": "File Header:",
  "bytecode_magic": "  Magic: 0x{0:08x}",
  "bytecode_version": "  Version: {0}",
  "bytecode_flags": "  Flags: 0x{0:08x}",
  "bytecode_entry_point": "  Entry Point: {0}",
  "bytecode_section_count": "  Section Count: {0}",
  "bytecode_file_size": "  File Size: {0} bytes",
  "bytecode_type_count": "  Type Table: {0} types",
  "bytecode_const_count": "  Constant Pool: {0} constants",
  "bytecode_func_count": "  Functions: {0}",
  "bytecode_func_name": "[{0:04}] {1}",
  "bytecode_func_params": "  Parameters: {0}",
  "bytecode_func_return_type": "  Return Type: {0}",
  "bytecode_func_local_count": "  Local Count: {0}",
  "bytecode_func_instr_count": "  Instructions: {0}",
  "bytecode_func_code": "  Code:",
  "bytecode_instr_index": "    [{0:04}] {1}",
  "bytecode_unknown_opcode": "    [{0:04}] Unknown opcode: 0x{1:02x}",

  "repl_welcome": "YaoXiang REPL v0.3.0",
  "repl_help": "Type :help for available commands, :quit to exit.",
  "repl_error": "Error: {0}",
  "repl_unknown_command": "Unknown command: {0}",

  "shell_welcome": "YaoXiang Development Shell v0.3.0",
  "shell_help": "Type :help for available commands.",
  "shell_exec_time": "Executed in {0:?}",
  "shell_loaded": "Loaded: {0}",
  "shell_debug_start": "Starting debug session for: {0}",
  "shell_debug_cmd": "Available commands:\n  (r)un    - Run to next breakpoint\n  (s)tep   - Step one instruction\n  (n)ext   - Step over function calls\n  (o)ut    - Step out of current function\n  (b)reak  - List breakpoints\n  (b)reak <n> - Add breakpoint at line n\n  (c)ont   - Continue execution\n  (q)uit   - Exit debugger",

  "debug_binary_op": "DEBUG: lhs_value={0:?}, rhs_value={1:?}",
  "debug_registers": "DEBUG: registers.len={0}, lhs_idx={1}, rhs_idx={2}",
  "debug_match": "DEBUG: Matched BinaryOp!",

  "formatter_not_implemented": "Formatter not implemented yet",

  "stage1_start": "=== 阶段 1: 错误和警告信息 ===",
  "stage1_complete": "=== 阶段 1 完成: 错误和警告信息 ===",
  "stage2_start": "=== 阶段 2: 用户可见消息 ===",
  "stage2_complete": "=== 阶段 2 完成: 用户可见消息 ===",
  "stage3_start": "=== 阶段 3: 调试信息和其他模块 ===",
  "stage3_complete": "=== 阶段 3 完成: 调试信息和其他模块 ===",
  "all_stages_complete": "=== 所有阶段完成！ ===",

  "bytecode_decode_i64add": "DEBUG decode: I64Add operands.len = {0}",
  "bytecode_decode_i64add_too_short": "DEBUG decode: I64Add operands too short, skipping",

  "ir_gen_enter_scope": "DEBUG IR gen: enter_scope, symbols stack depth before: {0}",
  "ir_gen_exit_scope": "DEBUG IR gen: exit_scope, symbols stack depth: {0}",
  "ir_gen_register_local": "DEBUG IR gen: register_local '{0}' with local_idx={1}",
  "ir_gen_lookup_local": "DEBUG IR gen: lookup_local '{0}' -> local_idx={1}",
  "ir_gen_lookup_local_not_found": "DEBUG IR gen: lookup_local '{0}' -> None",
  "ir_gen_before_process_stmt": "DEBUG IR gen: before processing stmt, symbols depth={0}",
  "ir_gen_after_process_stmt": "DEBUG IR gen: after processing stmt, symbols depth={0}",
  "ir_gen_about_to_exit_scope": "DEBUG IR gen: about to exit_scope, symbols depth={0}",
  "ir_gen_after_exit_scope": "DEBUG IR gen: after exit_scope, symbols depth={0}",

  "repl_available_commands": "Available commands:",
  "repl_exit_command": "  :quit, :q   - Exit the REPL",
  "repl_help_command": "  :help, :h   - Show this help message",
  "repl_history_command": "  :history    - Show input history",
  "repl_clear_command": "  :clear      - Clear the input buffer",

  "shell_exiting": "\\nExiting...",
  "shell_available_commands": "Shell Commands:",
  "shell_exit_command": "  :quit, :q, exit   - Exit the shell",
  "shell_clear_command": "  :clear            - Clear the screen",
  "shell_cd_command": "  :cd <dir>         - Change directory",
  "shell_pwd_command": "  :pwd              - Print working directory",
  "shell_ls_command": "  :ls [dir]         - List directory contents",
  "shell_code_commands": "Code Commands:",
  "shell_run_command": "  :run <file>       - Run a YaoXiang file",
  "shell_load_command": "  :load <file>      - Load a YaoXiang file",
  "shell_debug_command": "  :debug <file>     - Debug a YaoXiang file",
  "shell_break_command": "  :break <fn> <n>   - Set breakpoint",
  "shell_repl_command": "  :repl             - Switch to REPL mode",
  "shell_other_input": "Any other input is evaluated as YaoXiang code.",

  "debugger_at_location": "  at {0}:{1}",
  "debugger_locals": "  Locals:",
  "debugger_call_stack": "  Call stack:",

  "parser_test_parsed_params": "Parsed params: {0:?}",
  "parser_test_parsed_return_type": "Parsed return_type: {0:?}",
  "parser_test_parsed_as_var": "Parsed as Var instead of Fn",
  "parser_test_name": "Name: {0}",
  "parser_test_annotation": "Annotation: {0:?}",

  "repl_value": "{0}",
  "repl_prompt": "{0}",
  "repl_history_entry": "[{0}] {1}",

  "shell_exec_time": "Executed in {0:?}",
  "shell_loaded": "Loaded: {0}",
  "shell_debug_start": "Starting debug session for: {0}",
  "shell_debug_cmd": "Available commands:\n  (r)un    - Run to next breakpoint\n  (s)tep   - Step one instruction\n  (n)ext   - Step over function calls\n  (o)ut    - Step out of current function\n  (b)reak  - List breakpoints\n  (b)reak <n> - Add breakpoint at line n\n  (c)ont   - Continue execution\n  (q)uit   - Exit debugger"
}
