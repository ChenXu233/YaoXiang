{
  "cmd_received": "Run command received",
  "run_file": "Running file",
  "reading_file": "Reading file: {0}",
  "build_bytecode": "Building bytecode",
  "writing_bytecode": "Writing bytecode to: {0}",
  "lex_start": "Starting lexical analysis",
  "lex_complete": "Lexical analysis completed",
  "lex_complete_tokens": "Lexical analysis completed: {0} tokens",
  "lex_token_identifier": "Lexer: identifier {0}",
  "lex_token_keyword": "Lexer: keyword {0}",
  "lex_token_number": "Lexer: number {0}",
  "lex_token_string": "Lexer: string \"{0}\"",
  "lex_token_char": "Lexer: char '{0}'",
  "lex_token_operator": "Lexer: operator {0}",
  "lex_token_punctuation": "Lexer: punctuation {0}",
  "parser_start": "Starting parsing {0} tokens",
  "parser_complete": "Parsing completed",
  "parser_complete_items": "Parsing completed: {0} items",
  "parser_parse_stmt": "Parsing statement: {0}",
  "parser_parse_expr": "Parsing expression",
  "parser_parse_fn_def": "Parsing function definition: {0}",
  "parser_parse_let": "Parsing variable binding: {0}",
  "parser_parse_return": "Parsing return statement",
  "parser_parse_if": "Parsing if statement",
  "parser_parse_loop": "Parsing loop statement",
  "parser_parse_block": "Parsing block",
  "typecheck_start": "Starting type checking",
  "typecheck_complete": "Type checking completed",
  "typecheck_process_fn": "Processing function: {0}",
  "typecheck_has_annotation": "Has type annotation: {0}",
  "typecheck_annotation": "Type annotation: {0}",
  "typecheck_annotated": "Annotated: {0}, untyped params: {1}",
  "typecheck_add_error": "Adding error for param: {0}",
  "typecheck_call_fndef": "Checking function definition",
  "typecheck_infer_expr": "Inferring expression type",
  "typecheck_infer_fn": "Inferring function: {0}",
  "typecheck_add_constraint": "Adding constraint: {0} = {1}",
  "typecheck_solve_constraints": "Solving type constraints",
  "typecheck_var_binding": "Variable binding: {0} : {1}",
  "codegen_start": "Starting code generation",
  "codegen_complete": "Code generation completed",
  "codegen_functions": "Code generation completed: {0} functions",
  "codegen_const_pool": "Generating constant pool: {0} constants",
  "codegen_code_section": "Generating code section: {0} functions",
  "codegen_type_table": "Generating type table: {0} types",
  "codegen_gen_fn": "Generating function: {0}",
  "codegen_gen_block": "Generating basic block",
  "codegen_gen_instr": "Generating instruction: {0}",
  "codegen_reg_alloc": "Allocating register: {0}",
  "codegen_add_const": "Adding constant: {0}",
  "vm_start": "VM starting execution",
  "vm_complete": "VM execution completed",
  "vm_execute_fn": "Executing function: {0}",
  "vm_exec_instruction": "Executing instruction: {0}",
  "vm_call_stack": "Call stack depth: {0}",
  "vm_push_frame": "Pushing frame: {0}",
  "vm_pop_frame": "Popping frame",
  "vm_load_local": "Load local: idx={0}, val={1}",
  "vm_store_local": "Store local: idx={0}",
  "vm_load_arg": "Load arg: idx={0}",
  "vm_reg_read": "Read register: r{0} = {1}",
  "vm_reg_write": "Write register: r{0} = {1}",
  "vm_push_stack": "Push stack: {0}",
  "vm_pop_stack": "Pop stack",
  "vm_call_func": "Call function: {0}",
  "vm_return_func": "Function return",
  "compilation_start": "Starting compilation",
  "compiling_source": "Compiling source code ({0} bytes)",
  "debug_run_called": "run() called",
  "debug_checking_stmt": "Checking statement",
  "debug_stmt_expr": "Statement kind: Expr",
  "debug_stmt_fn": "Statement kind: Fn for {0}",
  "debug_checking_type": "Checking type definition for {0}",
  "debug_struct_type": "Registering struct type '{0}' in scope",
  "debug_non_struct_type": "Registering non-struct type '{0}' in scope",
  "debug_loading_function": "Loading function '{0}' into interpreter",
  "debug_total_functions": "Total functions loaded: {0}",
  "debug_available_functions": "Available functions: {0}",
  "debug_function_lookup": "Looking up function '{0}' (lookup_name: '{1}')",
  "debug_function_found": "Found function '{0}'",
  "debug_function_call": "Calling function '{0}' with args: {1}",
  "debug_function_return": "Function '{0}' returned: {1}",
  "debug_exec_binary_op": "Executing binary operation: lhs={0}, rhs={1}, op={2}",
  "debug_adding_numbers": "Adding {0} + {1}",
  "debug_struct_type_constructor_call": "Detected struct type constructor call for {0}",
  "debug_translating_instr": "Translating instruction: {0}",
  "debug_generating_ir_binop": "Generating IR for BinOp {0}",
  "error_unknown_variable": "Unknown variable: {0}",
  "error_unknown_type": "Unknown type: {0}",
  "error_type_mismatch": "Type mismatch: expected {0}, found {1}",
  "error_arity_mismatch": "Arity mismatch: expected {0} arguments, found {1}",
  "error_index_out_of_bounds": "Index out of bounds: {0} (size: {1})",
  "error_unknown_field": "Unknown field '{0}' in '{1}'",
  "error_recursive_type": "Recursive type definition: {0}",
  "error_unsupported_op": "Unsupported operation: {0}",
  "error_non_exhaustive_patterns": "Non-exhaustive patterns: missing {0} pattern(s)",
  "error_import_error": "Import error: {0}",
  "error_inference_failed": "Inference failed: {0}",
  "error_cannot_infer_param_type": "Cannot infer type for parameter '{0}': parameter has no type annotation and is not used in a way that allows inference",
  "help_did_you_mean": "did you mean {0}?",
  "help_similar_variables": "similar variables: {0}",
  "help_in_scope": "in scope: {0}"
}
