# RFC-003：版本规划与实现建议

> **状态**: 草案
> **作者**: 晨煦
> **创建日期**: 2025-01-05
> **最后更新**: 2025-01-05

## 摘要

提出YaoXiang的版本发布计划和分阶段实现策略，包含从v0.1到v1.0的路线图、组件实现优先级、工具链规划和生态建设策略。

## 动机

### 为什么需要清晰的版本规划？

- **项目管理**：将宏大目标分解为可执行的里程碑
- **用户预期**：让用户了解语言的发展阶段和成熟度
- **资源分配**：明确每个阶段的重点和优先级
- **风险控制**：及时发现问题并调整方向

### 核心原则

```
渐进式交付 ──→ 每个版本都有可用功能
向后兼容 ──→ 避免破坏性变更
质量优先 ──→ 每个版本都经过充分测试
```

## 提案

### 1. 版本路线图

#### 1.1 总体时间线

```
v0.1 ─────────── v0.3 ─────────── v0.5 ─────────── v0.7 ─────────── v1.0
  │               │               │               │               │
  │               │               │               │               │
同步核心         显式并发         透明并发         优化完善         稳定发布
(1-2月)          (2-3月)          (3-4月)          (2-3月)          (2-3月)
```

#### 1.2 各版本详情

| 版本       | 目标    | 时间   | 核心特性                  | 成熟度 |
| -------- | ----- | ---- | --------------------- | --- |
| **v0.1** | 同步解释器 | 1-2月 | `@block`模式、基础类型、REPL  | 原型  |
| **v0.3** | 显式并发  | 2-3月 | `spawn`块、工作窃取调度、libuv | 试验  |
| **v0.5** | 透明并发  | 3-4月 | L3完全透明、DAG分析、错误图      | 预览  |
| **v0.7** | 优化完善  | 2-3月 | 性能优化、工具链完善、稳定化        | 测试  |
| **v1.0** | 稳定发布  | 2-3月 | 完整功能、生产可用、文档齐全        | 稳定  |

#### 1.3 版本发布标准

```
v0.x 系列：
  - 功能完整但可能存在边界情况问题
  - API可能变更
  - 仅供学习和试验

v1.0：
  - 所有核心功能稳定
  - API冻结
  - 适合生产使用
  - 完整的文档和教程
```

### 2. 分阶段实现策略

#### 2.1 阶段1：同步核心（v0.1）

**目标**：最小可用产品，验证核心类型系统和解释器

##### 里程碑

| 里程碑  | 内容    | 验收标准               |
| ---- | ----- | ------------------ |
| M1.1 | 项目骨架  | cargo项目初始化、目录结构    |
| M1.2 | 词法分析器 | 17个关键字识别、token生成   |
| M1.3 | 语法分析器 | AST构建、基础语法解析       |
| M1.4 | 类型推断  | Hindley-Milner算法实现 |
| M1.5 | 解释器   | 顺序执行、基础REPL        |

##### 组件实现状态

| 组件 | 状态 | 说明 |
|------|------|------|
| 词法分析器 | 待开发 | 17个关键字：`type`、`fn`、`let`、`if`、`for`、`match`、`spawn`、`@block`、`@eager`、`@ordered`、`pub`、`mod`、`import`、`as`、`true`、`false`、`null` |
| 语法分析器 | 待开发 | AST构建、优先级解析 |
| 类型推断 | 待开发 | Hindley-Milner、多态支持 |
| 解释器 | 待开发 | 顺序执行、闭包支持 |
| REPL | 待开发 | 交互式解释器 |

##### v0.1支持的语法

```yaoxiang
# 基础类型
x: Int = 42
y: Float = 3.14
name: String = "YaoXiang"
flag: Bool = true

# 类型定义
type Point = Point(x: Float, y: Float)
type Result[T, E] = ok(T) | err(E)

# 函数定义
add: (Int, Int) -> Int = (a, b) => a + b
inc: Int -> Int = x => x + 1

# 控制流
factorial: (Int) -> Int = (n) => {
    if n <= 1 {
        1
    } else {
        n * factorial(n - 1)
    }
}

# match表达式
match x {
    0 => "zero"
    n if n > 0 => "positive"
    _ => "negative"
}

# @block模式（仅同步）
main: () -> Void @block = () => {
    print("Hello, YaoXiang!")
}
```

#### 2.2 阶段2：显式并发（v0.3）

**目标**：验证并作模型可行性，实现`spawn`块和基础调度器

##### 里程碑

| 里程碑 | 内容 | 验收标准 |
|--------|------|----------|
| M2.1 | DAG构建 | 程序到依赖图的转换 |
| M2.2 | 工作窃取调度器 | 并行任务执行 |
| M2.3 | spawn语法 | `spawn { }` 块支持 |
| M2.4 | libuv集成 | 异步I/O基础 |
| M2.5 | 基础测试套件 | 并发正确性验证 |

##### 组件实现状态

| 组件 | 状态 | 说明 |
|------|------|------|
| DAG构建器 | 待开发 | 依赖分析、图生成 |
| 调度器 | 待开发 | 工作窃取、多线程 |
| spawn块解析 | 待开发 | 并发语法解析 |
| libuv绑定 | 待开发 | 文件I/O、网络I/O |
| 线程池 | 待开发 | 阻塞操作管理 |

##### v0.3支持的语法

```yaoxiang
# 显式spawn并发
fetch_data: (String) -> JSON spawn = (url) => {
    HTTP.get(url).json()
}

process: () -> Void spawn = () => {
    users = fetch_data("https://api.example.com/users")
    posts = fetch_data("https://api.example.com/posts")

    # users 和 posts 自动并行执行
    print(users.length.to_string())
    print(posts.length.to_string())
}

# spawn并发块
compute_all: () -> (Int, Int, Int) spawn = () => {
    (a, b, c) = spawn {
        heavy_calc(1),
        heavy_calc(2),
        heavy_calc(3)
    }
    (a, b, c)
}
```

#### 2.3 阶段3：透明并发（v0.5）

**目标**：完整的并作模型，L3模式自动并行化

##### 里程碑

| 里程碑 | 内容 | 验收标准 |
|--------|------|----------|
| M3.1 | L3默认透明 | 无标记函数自动并行 |
| M3.2 | 资源冲突检测 | 编译时冲突分析 |
| M3.3 | 错误图系统 | 可视化错误传播 |
| M3.4 | 性能优化 | 并行效率达标 |
| M3.5 | 文档完善 | 教程和示例 |

##### 组件实现状态

| 组件 | 状态 | 说明 |
|------|------|------|
| 自动并行化 | 待开发 | DAG优化、依赖分析 |
| 资源分析器 | 待开发 | 冲突检测 |
| 错误图生成器 | 待开发 | 错误传播追踪 |
| 调试器原型 | 待开发 | 基础调试功能 |
| 性能分析器 | 待开发 | 瓶颈识别 |

##### v0.5支持的语法

```yaoxiang
# L3完全透明（默认模式）
heavy_calc: (Int) -> Int = (n) => {
    fibonacci(n)  # 默认惰性求值
}

auto_parallel: (Int) -> Int = (n) => {
    # 系统自动分析：a, b, c 无依赖，可完全并行
    a = heavy_calc(1)
    b = heavy_calc(2)
    c = heavy_calc(3)
    a + b + c  # 在此处等待所有结果
}

# 数据并行循环（自动并行化）
parallel_sum: (Int) -> Int spawn = (n) => {
    total = spawn for i in 0..n {
        fibonacci(i)  # 每次迭代并行执行
    }
    total
}

# 资源冲突检测示例
# 编译器自动检测并串行化冲突操作
file_a = open("a.txt")  # 资源1
file_b = open("b.txt")  # 资源2
# 写操作冲突自动串行化
```

#### 2.4 阶段4：优化完善（v0.7）

**目标**：性能优化、稳定性提升、工具链完善

##### 里程碑

| 里程碑 | 内容 | 验收标准 |
|--------|------|----------|
| M4.1 | 性能优化 | 编译速度、执行效率 |
| M4.2 | 工具链完善 | LSP、格式化、clippy |
| M4.3 | 标准库扩展 | 常用数据结构 |
| M4.4 | 稳定性提升 | 边界情况处理 |
| M4.5 | 兼容性测试 | 跨平台测试 |

##### 工具链开发

| 工具 | 优先级 | 说明 |
|------|--------|------|
| yaoxiang-lsp | P0 | 语言服务器协议支持 |
| yaoxiang-fmt | P0 | 代码格式化 |
| yaoxiang-clippy | P1 | 静态检查 |
| yaoxiang-debug | P2 | 图形化调试器 |

#### 2.5 阶段5：稳定发布（v1.0）

**目标**：生产可用、文档齐全、生态启动

##### 里程碑

| 里程碑 | 内容 | 验收标准 |
|--------|------|----------|
| M5.1 | API冻结 | 不再发生破坏性变更 |
| M5.2 | 完整文档 | 语言指南、API文档、教程 |
| M5.3 | 生态启动 | 包管理器、第三方库 |
| M5.4 | 社区建设 | 贡献指南、Issue模板 |
| M5.5 | 发布准备 | 版本发布流程 |

### 3. 实现优先级

#### 3.1 特性优先级矩阵

| 优先级 | 特性 | 理由 |
|--------|------|------|
| **P0** | 基础类型系统 | 语言核心，无此不可用 |
| **P0** | 函数定义与调用 | 语言核心 |
| **P0** | 控制流(if/for/match) | 必需的控制结构 |
| **P0** | @block同步模式 | v0.1交付目标 |
| **P1** | spawn并发语法 | v0.3交付目标 |
| **P1** | DAG依赖分析 | 并发核心 |
| **P1** | Result类型与错误处理 | 健壮性必需 |
| **P1** | libuv集成 | 异步I/O基础 |
| **P2** | L3透明并发 | 高级特性 |
| **P2** | 依赖类型 | 长期特性 |
| **P2** | 元编程 | 长期特性 |

#### 3.2 组件依赖关系

```
v0.1 依赖图：
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  词法分析 ──► 语法分析 ──► 类型推断 ──► 解释器 ──► REPL   │
│      │                                              │       │
│      └──────────────────────────────────────────────┘       │
│                                                             │
└─────────────────────────────────────────────────────────────┘

v0.3 依赖图：
┌─────────────────────────────────────────────────────────────┐
│  v0.1                                                    │
│    │                                                     │
│    ▼                                                     │
│  DAG构建 ──► 工作窃取调度器 ──► spawn块支持               │
│    │                                    │                 │
│    │                                    ▼                 │
│    └──────────────────┬────────────────────────┘          │
│                       ▼                                    │
│                  libuv集成                                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 4. 生态建设策略

#### 4.1 寄生策略

| 阶段 | 策略 | 说明 |
|------|------|------|
| **短期** | 调用Rust库 | 复用crates.io生态，寄生Cargo |
| **中期** | 多目标编译 | WASM（浏览器）、JVM、.NET |
| **长期** | 自建生态 | 标准库、包管理器、第三方库 |

##### 短期：Rust生态寄生

```toml
# Cargo.toml
[dependencies]
# 直接使用成熟Rust库
anyhow = "1"           # 错误处理
serde = { version = "1", features = ["derive"] }  # 序列化
tokio = { version = "1", features = ["full"] }    # 异步（备选）
libc = "0.2"           # C FFI
```

##### 中期：多目标编译

```
YaoXiang源代码
     │
     ├──► native ──► 本地可执行文件
     │
     ├──► wasm32-unknown-unknown ──► 浏览器运行
     │        │
     │        └──► JavaScript互操作
     │
     └──► wasm32-wasi ──► WASI运行环境
              │
              └──► 系统调用抽象
```

#### 4.2 工具链优先策略

```
工具链开发优先级：
┌─────────────────────────────────────────────────────────────┐
│  第一阶段（v0.1-v0.3）                                       │
│  ├── yaoxiang-cli     命令行工具                            │
│  ├── yaoxiang-fmt     代码格式化（基于AST）                  │
│  └── yaoxiang-lsp     基础LSP支持                           │
├─────────────────────────────────────────────────────────────┤
│  第二阶段（v0.5-v0.7）                                       │
│  ├── yaoxiang-clippy  静态分析、代码质量                    │
│  ├── yaoxiang-debug   基础调试支持                          │
│  └── yaoxiang-test    测试框架                              │
├─────────────────────────────────────────────────────────────┤
│  第三阶段（v1.0+）                                           │
│  ├── yaoxiang-debug   图形化调试器（DAG可视化）              │
│  ├── yaoxiang-profile 性能分析器                            │
│  └── yaoxiang-doc     文档生成器                            │
└─────────────────────────────────────────────────────────────┘
```

#### 4.3 标准库规划

| 模块 | 内容 | 优先级 |
|------|------|--------|
| `std::prim` | 基础类型（Int、Float、Bool、String） | P0 |
| `std::col` | 集合（List、Map、Set、Option） | P0 |
| `std::io` | I/O（File、Net、Process） | P0 |
| `std::sync` | 并发（Mutex、Arc、Channel） | P1 |
| `std::time` | 时间（Duration、Instant） | P1 |
| `std::fmt` | 格式化（print、debug） | P0 |
| `std::path` | 路径处理 | P1 |
| `std::json` | JSON解析 | P1 |
| `std::http` | HTTP客户端/服务器 | P2 |
| `std::regex` | 正则表达式 | P2 |

### 5. 成功指标

#### 5.1 技术指标

| 指标 | v0.1目标 | v0.5目标 | v1.0目标 |
|------|----------|----------|----------|
| 编译速度 | < 5s | < 10s | < 5s |
| 解释执行 | 基础正确 | 完整正确 | 优化执行 |
| 并行效率 | N/A | 60%线性 | 80%线性 |
| 错误消息 | 基础 | 清晰 | 友好+建议 |
| 覆盖率 | 50% | 80% | 95% |

#### 5.2 质量指标

| 指标 | 描述 |
|------|------|
| 稳定性 | 无崩溃、内存安全 |
| 兼容性 | 跨平台一致行为 |
| 可用性 | 文档齐全、示例丰富 |
| 性能 | 合理内存使用、执行效率 |

#### 5.3 社区指标

| 指标 | 描述 |
|------|------|
| 贡献者数量 | 活跃贡献者增长 |
| Issue响应 | 24小时内响应 |
| PR周期 | 1周内首次review |
| 文档完整性 | 核心功能100%覆盖 |

## 详细设计

### 1. 版本号语义

```
主版本.次版本.补丁版本

v1.2.3:
  - 1: 主版本（重大变更、API不兼容）
  - 2: 次版本（新功能、向后兼容）
  - 3: 补丁版本（bug修复、向后兼容）
```

### 2. 发布周期

| 版本类型 | 周期 | 特点 |
|----------|------|------|
| 补丁版本 | 每2-4周 | 快速bug修复 |
| 次版本 | 每2-3月 | 功能更新 |
| 主版本 | 每1-2年 | 重大变更 |

### 3. 发布检查清单

- [ ] 所有测试通过
- [ ] 性能基准达标
- [ ] 文档更新完成
- [ ] CHANGELOG撰写
- [ ] 版本号更新
- [ ] 标签和发布说明

## 权衡

### 优点

1. **渐进式交付**：每个版本都有可用的功能
2. **风险可控**：小步快跑，及时发现问题
3. **用户友好**：清晰的升级路径
4. **质量保证**：每个版本都有质量门槛

### 缺点

1. **前期功能受限**：v0.1功能有限
2. **API可能变更**：v1.0前不稳定
3. **资源投入**：多版本维护成本

## 替代方案

| 方案 | 为什么不选择 |
|------|--------------|
| 一次性发布完整功能 | 风险过高、周期过长 |
| 仅发布稳定版本 | 缺乏用户反馈 |
| 跟随Rust版本 | 失去自主性 |

## 实现策略

### 依赖关系

- RFC-001（并作模型）：提供并发设计
- RFC-002（libuv）：提供异步运行时

### 风险

1. **范围蔓延**：避免在v0.x中添加过多特性
2. **技术债务**：及时重构，避免积累债务
3. **资源不足**：保持现实的时间预期

## 开放问题

- [ ] JIT编译的时机选择（AOT vs JIT）
- [ ] 标准库的范围界定（内置vs外部库）
- [ ] 包管理器的设计决策
- [ ] 长期维护策略
- [ ] 社区治理模式

## 参考文献

- [语义化版本2.0.0](https://semver.org/lang/zh-CN/)
- [Rust发布模型](https://forge.rust-lang.org/release.html)
- [Chrome版本发布](https://www.chromium.org/developers/calendars/)
- [SemVer最佳实践](https://doc.rust-lang.org/cargo/reference/semver.html)
