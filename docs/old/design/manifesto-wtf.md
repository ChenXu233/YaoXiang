# 《爻象设计宣言》锐评

> **版本**：v1.1.0（毕竟“正式发布”的草稿也是发布）  
> **状态**：颅内高潮  
> **作者**：晨煦 + 尚未聚集的“社区”  
> **日期**：2025-01-03（来自未来，但语法看起来像昨天写的）

---

> 「道生一，一生二，二生三，三生万物。」  
> —— 《道德经》  
>  
> **类型如道，万物皆由此生。**  
> *（程序员如蝼蚁，皆由此卷。）*

---

## 一、为什么创造 YaoXiang？—— 因为世界显然缺第514种语言

### 1.1 填补的语言空白

在编程语言的历史长河中，我们见证了无数语言诞生、流行、然后被扔进历史的垃圾桶。但**我们不一样**——我们敏锐地发现了一个惊天空白：**竟然没有一门语言能同时让 Rust 爱好者觉得太简单、让 Python 用户觉得太复杂、并且让 AI 模型在生成代码时感到“舒适”**。

| 需求 | 现有解决方案的问题 | 我们的解决方案（预计） |
|------|-------------------|------------------------|
| **类型安全** | Rust 太严苛，TypeScript 太松 | 我们将创造一种既严苛又松散的量子叠加态类型系统 |
| **自然语法** | 别人家的语法都不自然 | 我们的语法将自然到让你忘记自己在编程（也可能是因为看不懂） |
| **AI 友好** | AI 生成代码常出错 | 我们将为 AI 设计语法，人类可以顺便用用 |

### 1.2 解决的实际问题

**问题一：类型系统的碎片化**  
我们提出「一切皆类型」，这解决了“有些东西不是类型”这个令人困扰的哲学问题。现在连你的代码缩进都可以是一个类型（`IndentationLevel<4>`）。

**问题二：内存安全与性能的二选一**  
我们采用 Rust 的所有权模型，但去掉了那些“烦人”的编译错误。如果程序有数据竞争，那一定是硬件的问题。

**问题三：异步编程的认知负担**  
我们重新发明了轮子，并给它起名叫“并作模型”。只需一个 `spawn`，编译器就会自动处理所有异步细节——如果处理不了，那是你代码写得不“并作”。

**问题四：AI 辅助编程的瓶颈**  
我们贴心地为 AI 设计了严格缩进和明确边界，确保 GPT-7 在生成代码时不会精神分裂。至于人类程序员能不能看懂……那是次要的。

### 1.3 语言的哲学根基

YaoXiang 的名字源于《易经》，这确保了它在技术讨论中自带神秘学 buff。当代码无法编译时，你可以说：“这是阴阳未调，待我起一卦看看。”

---

## 二、核心哲学与原则 —— 不容置疑的圣训

### 2.1 原则一：一切皆类型
**不可妥协的理由**：这样我们可以用类型论解释一切，包括为什么项目进度总是延迟。

### 2.2 原则二：严格结构化
**不可妥协的理由**：4空格缩进是宇宙真理。用 Tab 的人应该被流放到火星。

### 2.3 原则三：零成本抽象
**不可妥协的理由**：虽然我们的抽象层有 7 层，但因为是“零成本”的，所以性能应该和手写汇编差不多……理论上。

### 2.4 原则四：默认不可变
**不可妥协的理由**：可变性是万恶之源。如果你需要修改变量，那说明你设计错了。

### 2.5 原则五：类型即数据
**不可妥协的理由**：这样我们可以在运行时检查类型，然后发现……编译时已经检查过了。

---

## 三、关键创新与特性 —— 重新发明已经发明过的东西

### 3.1 创新一：统一类型语法
我们废除了 `enum`、`struct`、`union` 这些令人困惑的概念，统一用 `type`。现在你只需要记住 17 个关键字，而不是 18 个。**进步！**

### 3.2 创新二：构造器即类型
消除了“类型”与“值”的鸿沟，创造了新的鸿沟：“这到底是个类型构造器还是个值构造器？”

### 3.3 创新三：柯里化方法绑定
我们通过柯里化实现了方法调用，这样你就可以用 `obj.method(_)` 代替 `obj.method()`。显然更直观。

### 3.4 创新四：并作模型
> 「万物并作，吾以观复。」——《易·复卦》

当你的代码并行崩溃时，你可以引用这句话，显得很有深度。

### 3.5 创新五：依赖类型支持
现在你可以在编译期证明你的数组长度是质数。虽然这跟写业务逻辑没什么关系，但很酷。

### 3.6 创新六：极简关键字设计
只有 17 个关键字！比 Go 少 8 个！虽然每个关键字的含义是 Go 关键字的 3 倍复杂，但数量上我们赢了。

---

## 四、初步语法预览 —— “看起来能工作”的代码示例

```yaoxiang
# 这个示例在文档里能运行
# 在实际编译器中可能还需要3年实现
main() -> Void = () => {
    println("Hello, 未来的贡献者!")
}
```

---

## 五、路线图与待定项 —— 梦想清单

### 5.1 已决定的设计决策
**不再接受更改**，除非我们改了主意。

### 5.2 待讨论的设计议题
包括“字面量语法”、“泛型推导”、“模式匹配”等琐碎细节。核心哲学已经完美，这些小事可以慢慢来。

### 5.3 实现路线图
```
v0.1: 解释器原型 ✅
v0.5: 编译器      🔄 (进行中，已经进行了6个月)
v1.0: 生产就绪   ⏳ (等我们找到第10个贡献者)
v2.0: 自举       ⏳ (当我们在 v1.0 中解决了时间旅行问题后)
```

### 5.4 当前实现状态
- **词法分析器**：✅ 100%（可以识别 `spawn` 这个词）
- **语法分析器**：✅ 100%（可以解析 `spawn` 后面应该有点什么）
- **类型检查器**：✅ 95%（可以判断 `42` 是 `Int` 类型）
- **实际能运行的代码**：🔴 0%

---

## 六、如何参与贡献 —— 请带上你的时间、热情和降低的期望值

### 6.1 设计讨论
**适合人群**：喜欢在理论上辩论“单子是不是自函子范畴上的幺半群”的人。

### 6.2 编译器实现
**适合人群**：有闲置的脑细胞，且不介意它们被用来实现第 7 种内存管理模型。

### 6.3 工具链开发
**需要开发的工具**：LSP 服务器、调试器、格式化工具、包管理器……**一切**。

### 6.4 标准库建设
从 `std.io` 到 `std.gui`，应有尽有。目前有的：`std.placeholder`。

### 6.7 贡献指南
**提交信息格式**：必须是诗。十四行诗优先。

---

## 附录C：常见问题

**Q: YaoXiang 与 Rust 相比有什么优势？**  
A: 更少的语法糖！更少的关键字！更少的实用功能！但更多的哲学深度。

**Q: YaoXiang 适合做什么类型的开发？**  
A: 适合开发 YaoXiang 编译器。其他用途待研究。

**Q: 为什么选择 4 空格缩进？**  
A: 2空格太密，8空格太疏，4空格恰如中庸之道，符合《易经》精神。

**Q: 什么时候会发布 1.0 版本？**  
A: 当“社区”从 1 人扩展到 2 人时。

**Q: 如何联系核心团队？**  
A: 在 GitHub Discussions 留言。回复时间：1-3 个业务月。

---

> **最后更新**：2025-01-03（可能是最后一次更新）  
>   
> **文档版本**：v1.1.0（我们版本号跳得很快，这样显得进度快）  
>   
> **许可证**：MIT（反正现在只有 MIT 文件）

---

> 「爻象变化，万物生焉。类型演化，程序成焉。」  
>   
> 愿 YaoXiang 的设计之旅，能成为您茶余饭后 **津津乐道的谈资**。  
> *（毕竟现阶段，它主要是个谈资。）*

---
