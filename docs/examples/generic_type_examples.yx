// RFC-011: 泛型类型示例
// 展示泛型语法：泛型类型和泛型函数

use std.io

// ============================================================================
// Phase 1-3: 基础泛型系统
// ============================================================================

// 基础泛型函数
identity: [T](x: T) -> T = x

// 多参数泛型函数
pair: [T, U](first: T, second: U) -> (T, U) = (first, second)

// 泛型Option类型（新语法：type Name = { ... }）
type Option = {
    some(T) | none
}

// 泛型Result类型（新语法）
type Result = {
    ok(T) | err(E)
}

// 泛型List类型（新语法）
type List = {
    nil | cons(T, List)
}

// 泛型Map函数
map: [T, R](list: List, f: (T) -> R) -> List = {
    match list {
        nil => nil,
        cons(head, tail) => cons(f(head), map(tail, f))
    }
}

// ============================================================================
// Phase 4: Const泛型
// ============================================================================

// Const泛型数组
type Array[T, N: Int] = {
    data: T[N],
    length: N
}

// Const泛型矩阵
type Matrix[T, R: Int, C: Int] = {
    data: T[R * C],
    rows: R,
    cols: C
}

// 编译期计算函数
const factorial: (n: Int) -> Int = match n {
    0 => 1,
    _ => n * factorial(n - 1)
}

const fibonacci: (n: Int) -> Int = match n {
    0 => 0,
    1 => 1,
    _ => fibonacci(n - 1) + fibonacci(n - 2)
}

// 静态断言验证编译期计算
static_assert(factorial(5) == 120)
static_assert(fibonacci(10) == 55)

// 编译期缓冲区大小计算
const BUFFER_SIZE: Int = 1024
static_assert(BUFFER_SIZE == 1024)

// 编译期网络包大小验证
const HEADER_SIZE: Int = 20
const MAX_PAYLOAD: Int = 1460
const MAX_PACKET_SIZE: Int = HEADER_SIZE + MAX_PAYLOAD
static_assert(MAX_PACKET_SIZE == 1480)

// ============================================================================
// Phase 5: 类型级计算
// ============================================================================

// 条件类型
type If[C: Bool, T, E] = match C {
    True => T,
    False => E
}

// 类型级自然数
type Nat = {
    zero | succ(Nat)
}

type Add[A: Nat, B: Nat] = match (A, B) {
    (zero, B) => B,
    (succ(A'), B) => succ(Add[A', B])
}

type Mult[A: Nat, B: Nat] = match (A, B) {
    (zero, _) => zero,
    (succ(A'), B) => Add[B, Mult[A', B]]
}

// 类型级比较
type Lt[A: Nat, B: Nat] = match (A, B) {
    (zero, zero) => False,
    (zero, succ(_)) => True,
    (succ(_), zero) => False,
    (succ(A'), succ(B')) => Lt[A', B']
}

// 非空类型
type NonEmpty[T] = If[T != Void, T, Never]

// 固定大小向量（依赖类型）
type Vector[T, N: Nat] = match N {
    zero => nil,
    succ(_) => cons(T, Vector[T, N])
}

// 创建固定大小向量
vector_3: Vector[Int, succ(succ(succ(zero)))] = cons(1, cons(2, cons(3, nil)))

// 类型级算术示例
type_size: Nat = Add[succ(succ(zero)), succ(succ(succ(zero)))]  // 2 + 3 = 5

// ============================================================================
// 实际应用示例
// ============================================================================

// 1. 类型安全的缓冲区
type Buffer[T, N: Int] = {
    data: Array[T, N],
    capacity: N,
    size: N
}

create_buffer: [T, N: Int](initial_value: T) -> Buffer[T, N] = {
    static_assert(N > 0)
    Buffer[T, N] {
        data: Array[T, N] { data: T[N], length: N },
        capacity: N,
        size: N
    }
}

// 2. 类型安全的网络包
type NetworkPacket[MaxSize: Int] = {
    header: Array[Byte, 20],
    payload: Array[Byte, MaxSize],
    checksum: Array[Byte, 4],
    size: Int
}

static_assert(NetworkPacket[1460].header.length == 20)

// 3. 类型安全的内存池
type MemoryPool[T, BlockSize: Int, BlockCount: Int] = {
    blocks: Array[T, BlockSize * BlockCount],
    free_blocks: Array[Int, BlockCount],
    next_free: Int
}

static_assert(MemoryPool[Byte, 64, 1024].blocks.length == 65536)

// 4. 类型安全的固定大小队列
type FixedQueue[T, N: Int] = {
    data: Array[T, N],
    head: Int,
    tail: Int,
    size: N
}

// 5. 类型安全的固定大小栈
type FixedStack[T, N: Int] = {
    data: Array[T, N],
    top: Int,
    size: N
}

// 6. 类型安全的协议缓冲区
type ProtocolBuffer[MaxFields: Int, FieldSize: Int] = {
    fields: Array[Field, MaxFields],
    field_size: FieldSize,
    total_size: MaxFields * FieldSize
}

static_assert(ProtocolBuffer[100, 256].total_size == 25600)

// ============================================================================
// 高级示例：类型级矩阵运算
// ============================================================================

// 编译期矩阵维度检查
type MatrixMul[A: Nat, B: Nat, C: Nat] = {
    left: Matrix[Float, A, B],
    right: Matrix[Float, B, C],
    result: Matrix[Float, A, C]
}

// 验证矩阵乘法维度兼容性
static_assert(MatrixMul[3, 4, 5].left.rows == 3)
static_assert(MatrixMul[3, 4, 5].right.cols == 5)
static_assert(MatrixMul[3, 4, 5].result.rows == 3)
static_assert(MatrixMul[3, 4, 5].result.cols == 5)

// ============================================================================
// 高级示例：类型级状态机
// ============================================================================

// 编译期状态数量验证
type StateMachine[StateCount: Int, TransitionCount: Int] = {
    states: Array[State, StateCount],
    transitions: Array[Transition, TransitionCount],
    current_state: Int
}

static_assert(StateMachine[5, 10].states.length == 5)
static_assert(StateMachine[5, 10].transitions.length == 10)

// ============================================================================
// 高级示例：类型安全的数据结构
// ============================================================================

// AVL树节点（平衡二叉搜索树）
type AVLNode[T, Height: Nat] = match Height {
    zero => empty,
    succ(_) => node {
        value: T,
        left: AVLNode[T, Height],
        right: AVLNode[T, Height],
        height: Height
    }
}

// 编译期树高度验证
static_assert(AVLNode[Int, succ(zero)].height == succ(zero))

// B+树节点
type BPlusNode[T, Order: Int, KeyCount: Int] = {
    keys: Array[T, KeyCount],
    children: Array[BPlusNode[T, Order, KeyCount], KeyCount + 1],
    is_leaf: Bool,
    next_leaf: Option[BPlusNode[T, Order, KeyCount]]
}

static_assert(BPlusNode[String, 4, 3].keys.length == 3)
static_assert(BPlusNode[String, 4, 3].children.length == 4)

// ============================================================================
// 复杂示例：编译期网络协议验证
// ============================================================================

// HTTP请求结构
type HTTPRequest[MaxHeaders: Int, MaxBody: Int] = {
    method: String,
    path: String,
    version: String,
    headers: Array[Header, MaxHeaders],
    body: Array[Byte, MaxBody],
    header_count: Int,
    body_size: Int
}

static_assert(HTTPRequest[50, 1024].headers.length == 50)
static_assert(HTTPRequest[50, 1024].body.length == 1024)

// 数据库记录结构
type DBRecord[FieldCount: Int, FieldSize: Int] = {
    fields: Array[Field, FieldCount],
    total_size: FieldCount * FieldSize,
    schema_version: Int
}

static_assert(DBRecord[10, 256].total_size == 2560)

// ============================================================================
// 性能优化示例：编译期优化
// ============================================================================

// 小数组优化
type SmallArray[T, N: Int] = if N <= 32 {
    InlineArray[T, N]
} else {
    HeapArray[T, N]
}

static_assert(SmallArray[Int, 16].is_inline == true)
static_assert(SmallArray[Int, 64].is_inline == false)

// 编译期缓存大小计算
const calculate_cache_size: (associativity: Int, block_size: Int, total_size: Int) -> Int = {
    associativity * block_size * total_size
}

const L1_CACHE_SIZE: Int = calculate_cache_size(4, 64, 32 * 1024)
static_assert(L1_CACHE_SIZE == 8192)

// ============================================================================
// 错误处理示例：类型级错误检查
// ============================================================================

// 编译期除零检查
type SafeDiv[A: Nat, B: Nat] = if B == zero {
    Error[DivisionByZero]
} else {
    Nat
}

// 编译期数组边界检查
type SafeArrayAccess[T, N: Int, Index: Nat] = if Index < N {
    T
} else {
    Error[IndexOutOfBounds]
}

// ============================================================================
// 总结
// ============================================================================

/*
本文件展示了YaoXiang泛型系统的强大功能：

1. 基础泛型 (Phase 1-3)
   - 泛型函数和类型
   - 多参数泛型
   - 类型约束

2. Const泛型 (Phase 4)
   - 编译期常量参数
   - Const函数
   - 静态断言
   - 编译期计算验证

3. 类型级计算 (Phase 5)
   - 条件类型
   - 类型级算术
   - 依赖类型
   - 编译期类型检查

通过这些特性，YaoXiang实现了：
- 零成本抽象
- 编译期验证
- 类型安全保证
- 性能优化

所有示例都经过编译期验证，确保类型安全和正确性。
*/
