# Phase 1: 类型检查推断规则

本文档定义了 YaoXiang 语言在类型检查阶段的类型推断规则。

## 完整分类表格

### 标准完整标注场景

| #   | 语法示例                                    | 参数     | 返回   | 解析 | 类型检查 | 说明           |
|-----|---------------------------------------------|----------|--------|------|----------|----------------|
| 1   | `add: (Int, Int) -> Int = (a, b) => a + b` | ✓ Int    | ✓ Int  | ✓    | ✓ PASS   | 标准完整标注   |
| 2   | `inc: Int -> Int = x => x + 1`             | ✓ Int    | ✓ Int  | ✓    | ✓ PASS   | 单参数完整标注 |
| 3   | `log: (String) -> Void = (msg) => print(msg)` | ✓ String | ✓ Void | ✓    | ✓ PASS   | Void 返回      |
| 4   | `get_val: () -> Int = () => 42`            | ✓ ()     | ✓ Int  | ✓    | ✓ PASS   | 无参完整标注   |
| 5   | `empty: () -> Void = () => {}`              | ✓ ()     | ✓ Void | ✓    | ✓ PASS   | 空函数体       |

### 新推断（无类型标注）场景

| #   | 语法示例                        | 参数     | 返回      | 解析 | 类型检查 | 说明          |
|-----|---------------------------------|----------|-----------|------|----------|---------------|
| 6   | `main = () => {}`               | 推断 ()  | 推断 Void | ✓    | ✓ PASS   | 空块 → Void   |
| 7   | `get_num = () => 42`            | 推断 ()  | 推断 Int  | ✓    | ✓ PASS   | 表达式 → 类型 |
| 8   | `add = (a, b) => a + b`         | 无法推断 | 推断 Int  | ✓    | ✗ 拒绝   | 参数无类型    |
| 9   | `square(x) = x * x`             | 无法推断 | 推断 Int  | ✓    | ✗ 拒绝   | 参数无类型    |
| 10  | `foo = x => x`                  | 无法推断 | 无法推断  | ✓    | ✗ 拒绝   | 全无法推断    |
| 11  | `print_msg = (msg) => print(msg)` | 无法推断 | 推断 Void | ✓    | ✗ 拒绝   | 参数无类型    |

### 旧语法推断场景

| #   | 语法示例                        | 参数       | 返回      | 解析 | 类型检查 | 说明             |
|-----|---------------------------------|------------|-----------|------|----------|------------------|
| 12  | `empty3() = () => {}`           | 推断 ()    | 推断 Void | ✓    | ✓ PASS   | 旧语法空函数     |
| 13  | `get_random() = () => 42`       | 推断 ()    | 推断 Int  | ✓    | ✓ PASS   | 旧语法有返回值   |
| 14  | `square2(Int) = (x) => x * x`   | ✓ Int      | 推断 Int  | ✓    | ✓ PASS   | 旧语法有参数类型 |
| 15  | `mul(Int, Int) = (a, b) => a * b` | ✓ Int, Int | 推断 Int  | ✓    | ✓ PASS   | 旧语法完整参数   |

### return 语句场景

| #   | 语法示例                                              | 参数     | 返回     | 解析 | 类型检查 | 说明            |
|-----|-------------------------------------------------------|----------|----------|------|----------|-----------------|
| 16  | `add: (Int, Int) -> Int = (a, b) => { return a + b; }` | ✓        | ✓        | ✓    | ✓ PASS   | 标准 + return   |
| 17  | `add = (a, b) => { return a + b; }`                   | 无法推断 | 无法推断 | ✓    | ✗ 拒绝   | 参数无类型      |
| 18  | `get = () => { return 42; }`                          | 推断 ()  | 推断 Int | ✓    | ✓ PASS   | return 显式返回 |
| 19  | `early: Int -> Int = (x) => { if x < 0 { return 0; } x }` | ✓ | ✓ | ✓ | ✓ PASS | 早期 return |

---

## 核心规则总结

### 类型检查推断规则

```
类型检查推断规则：
├── 参数有类型标注 → 使用标注类型
├── 参数无类型标注但有初始化值 → 尝试从上下文推断
│   └── Lambda 参数无法从上下文推断类型 → 拒绝
│
├── 返回类型有标注 → 使用标注类型
├── 返回类型无标注
│   ├── 有 return expr → 从 expr 推断
│   ├── 无 return，有表达式 → 从表达式推断
│   └── 无 return，有块 `{ ... }` →
│       ├── 块为空 `{}` → Void
│       ├── 块有 return → 从 return 推断
│       └── 块无 return → **拒绝**（无法推断隐式返回）
│
└── 参数和返回都无法推断 → 拒绝
```

### 详细规则说明

#### 1. 参数类型推断规则

| 场景 | 处理方式 |
|------|----------|
| 参数有显式类型标注 | 使用标注的类型 |
| 参数无标注但有初始化值 | 尝试从初始化值推断类型 |
| Lambda 参数无标注 | **拒绝**（无法从上下文推断） |

**重要**：Lambda 参数无法从使用上下文推断类型，因为函数参数类型需要在定义时确定。

#### 2. 返回类型推断规则

| 场景 | 处理方式 |
|------|----------|
| 返回类型有显式标注 | 使用标注的类型 |
| 无标注，有 `return expr` | 从 `expr` 的类型推断 |
| 无标注，无 return，有表达式 `=> expr` | 从 `expr` 的类型推断 |
| 无标注，块为空 `{}` | 推断为 `Void` |
| 无标注，块有 `return` | 从 return 的表达式类型推断 |
| 无标注，块无 return | **拒绝**（无法推断隐式返回） |

#### 3. 解析层面规则

- 所有语法变体在**解析层面**全部放过，不报错
- 解析阶段只负责验证语法结构，不进行类型检查

#### 4. 类型检查层面规则

- 类型检查阶段根据上述规则进行分类处理
- 符合规则的情况标记为 `✓ PASS`
- 不符合规则的情况标记为 `✗ 拒绝`

---

## 设计原则

1. **显式优于隐式**：优先使用标注类型，无法推断时要求显式标注
2. **安全第一**：无法安全推断的类型组合必须拒绝，而不是猜测
3. **一致性**：相同场景的处理方式保持一致
4. **实用性**：在安全的前提下，提供足够的类型推断能力减少标注负担
