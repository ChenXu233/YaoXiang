# 阶段五：字节码生成（第 6-7 周）

> 版本：v2.1.0 (高性能优化版 + 指令集完整化)
> 状态：实现规划
> 作者：晨煦
> 日期：2025-01-02

---

## 一、概述

### 1.1 目标

构建一个**强类型、寄存器架构、支持零成本抽象**的字节码系统。目标是生成的字节码在解释执行时能达到接近静态编译语言的性能（通过类型化指令），同时保留完整的运行时反射能力（通过懒加载元数据）。

### 1.2 核心设计哲学

| 原则 | 说明 |
|------|------|
| **运行时无类型检查** | 所有类型检查在编译期完成，字节码指令显式携带类型信息（如 `I64Add` 而非 `Add`）。 |
| **单态化泛型 (Monomorphization)** | 泛型在编译期展开，`List<int>` 和 `List<float>` 生成不同的代码，确保运行时无泛型开销。 |
| **确定性内存管理** | 基于所有权分析自动插入 `Retain/Release`，配合栈上值类型（Value Types）最小化堆分配。 |
| **按需反射 (Pay-as-you-go Reflection)** | 反射元数据独立存储，不使用不加载。反射调用通过**内联缓存 (Inline Cache)** 优化，首次慢，后续快。 |

---

## 二、性能核心：类型化指令与单态化

### 2.1 为什么需要类型化指令？

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     传统设计 vs 类型化指令设计                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  传统设计：                                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  ADD r1, r2, r3                                                       │   │
│  │                                                                       │   │
│  │  虚拟机执行流程：                                                      │   │
│  │  1. 解码指令 (1 cycle)                                                │   │
│  │  2. 读取 r2 类型标签 (2-3 cycles)                                     │   │
│  │  3. 读取 r3 类型标签 (2-3 cycles)                                     │   │
│  │  4. 动态分发 (5-10 cycles, 分支预测失败更慢)                          │   │
│  │  5. 执行加法 (1 cycle)                                                │   │
│  │                                                                       │   │
│  │  总计：10-20+ cycles，严重的分支预测问题                              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  类型化指令设计：                                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  I64Add r1, r2, r3   或   F64Add r1, r2, r3                          │   │
│  │                                                                       │   │
│  │  虚拟机执行流程：                                                      │   │
│  │  1. 解码指令 (1 cycle)                                                │   │
│  │  2. 直接执行对应 CPU 指令 (1 cycle)                                   │   │
│  │                                                                       │   │
│  │  总计：2 cycles，无分支，无类型检查                                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  性能提升：5-10x                                                            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 单态化编译策略

```rust
// 单态化 (Monomorphization) 编译步骤

// 源码：
// ```yaoxiang
// identity<T>(T) -> T = (x) => x
// list = [1, 2, 3]
// ```

// 单态化后（编译期）：
// ```yaoxiang
// identity_int(Int) -> Int = (x) => x
// identity_float(Float) -> Float = (x) => x
// identity_string(String) -> String = (x) => x
// list_int = [1, 2, 3]  // List<Int> -> List_int
// ```

// 字节码指令：
// identity_int:
//   I64Mov r1, r0        // 直接操作 64 位整数
//   Ret r1
//
// list_int:
//   I64Const r0, 1       // 立即数加载
//   I64Const r1, 2
//   I64Const r2, 3
//   NewList r3, 3        // 预知大小，无重分配
//   I64Store r3[0], r0
//   I64Store r3[1], r1
//   I64Store r3[2], r2
//   Ret r3
```

---

## 三、零成本反射：内联缓存机制

### 3.1 设计原理

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    内联缓存 (Inline Cache) 机制                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  设计目标：                                                                  │
│  1. 第一次调用：加载元信息，缓存                                              │
│  2. 后续调用：直接命中缓存，几乎零开销                                        │
│  3. 不使用反射：元信息从不加载，零开销                                        │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     CallDyn 指令格式                                 │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                      │   │
│  │   0          1          2-5        6-9       10-13    14+           │   │
│  │   ┌──────────┬──────────┬──────────┬──────────┬──────────┐        │   │
│  │   │ Opcode   │ IC Size  │ MethodName│ ArgCnt   │ArgTypes  │ ...   │   │
│  │   │ CallDyn  │ (u8)     │ Offset    │ (u32)    │ ID array │       │   │
│  │   │ 0x92     │          │ (u32)     │          │          │       │   │
│  │   └──────────┴──────────┴──────────┴──────────┴──────────┘        │   │
│  │                                                                      │   │
│  │   IC Size: 内联缓存大小（字节），0=禁用缓存                            │   │
│  │   MethodName: 方法名字符串在常量池中的偏移                            │   │
│  │   ArgCnt: 参数数量                                                    │   │
│  │   ArgTypes: 参数类型 ID 数组（用于类型检查）                          │   │
│  │                                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     执行流程                                         │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                      │   │
│  │   首次调用:                                                          │   │
│  │   ┌───────────────────────────────────────────────────────────────┐  │   │
│  │   │  1. 从常量池加载方法名                                          │  │   │
│  │   │  2. 在类型元数据中查找方法（O(log n)）                         │  │   │
│  │   │  3. 验证参数类型兼容性                                         │  │   │
│  │   │  4. 跳转到目标函数                                             │  │   │
│  │   │  5. 将 (类型ID, 函数地址) 写入 IC Slot                        │  │   │
│  │   │                                                               │  │   │
│  │   │  开销: ~1-10 μs（取决于元数据大小）                            │  │   │
│  │   └───────────────────────────────────────────────────────────────┘  │   │
│  │                                                                      │   │
│  │   后续调用:                                                          │   │
│  │   ┌───────────────────────────────────────────────────────────────┐  │   │
│  │   │  1. 读取 receiver 类型 ID                                     │  │   │
│  │   │  2. 对比 IC Slot 中的类型 ID                                  │  │   │
│  │   │  3. 若匹配，直接跳转函数地址                                   │  │   │
│  │   │  4. 若不匹配，回到首次调用流程                                 │  │   │
│  │   │                                                               │  │   │
│  │   │  开销: ~5-10 ns（一次内存读取 + 一次比较）                     │  │   │
│  │   └───────────────────────────────────────────────────────────────┘  │   │
│  │                                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 内联缓存数据结构

```rust
// src/vm/inline_cache.rs

/// 内联缓存槽
///
/// 位于函数调用点附近，缓存类型-地址映射
#[derive(Debug)]
#[repr(C, packed)]
pub struct InlineCacheSlot {
    /// 缓存的有效性标志
    pub valid: u8,          // 0 = 无效, 1 = 单态, 2 = 多态
    /// 缓存的类型数量
    pub count: u8,          // 1-4，通常为 1
    /// 缓存的插槽数据
    pub slots: [ICSlotData; 4],
}

/// 单个缓存插槽
#[derive(Debug)]
#[repr(C, packed)]
pub struct ICSlotData {
    /// 接收者类型 ID
    pub receiver_type_id: u32,
    /// 方法地址偏移（从代码段起始）
    pub method_offset: u32,
    /// 方法的虚表索引（用于虚调用）
    pub vtable_index: u16,
    /// 保留对齐
    pub _reserved: u16,
}

/// 内联缓存管理器
pub struct InlineCacheManager {
    /// 缓存池
    cache_pool: Vec<InlineCacheSlot>,
    /// 缓存大小配置
    config: ICConfig,
}

/// 内联缓存配置
#[derive(Debug, Clone)]
pub struct ICConfig {
    /// 是否启用内联缓存
    pub enabled: bool,
    /// 单态缓存大小
    pub monomorphic_size: usize,
    /// 多态缓存大小
    pub polymorphic_size: usize,
    /// 缓存失效策略
    pub invalidation_strategy: ICInvalidation,
}

impl Default for ICConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            monomorphic_size: 1,
            polymorphic_size: 4,
            invalidation_strategy: ICInvalidation::TypeChange,
        }
    }
}

/// 缓存失效策略
#[derive(Debug, Clone, Copy)]
pub enum ICInvalidation {
    /// 类型变化时失效
    TypeChange,
    /// 总是失效
    Always,
    /// 从不失效
    Never,
}

/// 内联缓存查找结果
pub enum ICCheckResult {
    /// 缓存命中，直接跳转
    Hit {
        /// 方法地址偏移
        method_offset: u32,
        /// 虚表索引
        vtable_index: u16,
    },
    /// 缓存未命中，需要查元数据
    Miss {
        /// 原因
        reason: ICMissReason,
    },
    /// 缓存失效
    Invalid,
}

/// 缓存未命中原因
#[derive(Debug, Clone, Copy)]
pub enum ICMissReason {
    /// 首次调用
    FirstCall,
    /// 多态缓存已满
    PolymorphicOverflow,
    /// 类型不匹配
    TypeMismatch,
}

impl InlineCacheManager {
    /// 检查缓存
    pub fn check_cache(
        &self,
        slot: &InlineCacheSlot,
        receiver_type_id: u32,
    ) -> ICCheckResult {
        if slot.valid == 0 {
            return ICCheckResult::Miss { reason: ICMissReason::FirstCall };
        }

        // 查找匹配的插槽
        for i in 0..slot.count as usize {
            if slot.slots[i].receiver_type_id == receiver_type_id {
                return ICCheckResult::Hit {
                    method_offset: slot.slots[i].method_offset,
                    vtable_index: slot.slots[i].vtable_index,
                };
            }
        }

        // 未找到，检查是否可以扩展为多态
        if slot.valid == 1 && slot.count < self.config.polymorphic_size as u8 {
            return ICCheckResult::Miss { reason: ICMissReason::PolymorphicOverflow };
        }

        ICCheckResult::Miss { reason: ICMissReason::TypeMismatch }
    }

    /// 更新缓存
    pub fn update_cache(
        &mut self,
        slot: &mut InlineCacheSlot,
        receiver_type_id: u32,
        method_offset: u32,
        vtable_index: u16,
    ) {
        if slot.valid == 0 {
            // 首次初始化
            slot.valid = 1;
            slot.count = 1;
            slot.slots[0] = ICSlotData {
                receiver_type_id,
                method_offset,
                vtable_index,
                _reserved: 0,
            };
        } else if slot.count < 4 {
            // 扩展多态缓存
            slot.valid = 2;  // 多态
            slot.slots[slot.count as usize] = ICSlotData {
                receiver_type_id,
                method_offset,
                vtable_index,
                _reserved: 0,
            };
            slot.count += 1;
        } else {
            // 缓存已满，替换第一个（LRU 简化版）
            slot.slots[0] = ICSlotData {
                receiver_type_id,
                method_offset,
                vtable_index,
                _reserved: 0,
            };
        }
    }
}
```

---

## 四、内存管理：分层策略

### 4.1 分层内存管理架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        内存管理分层策略                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        栈分配（零开销）                               │   │
│  │  • 不逃逸的局部变量                                                   │   │
│  │  •（< 64 小型结构体 字节）                                            │   │
│  │  • 闭包捕获但不逃逸的变量                                             │   │
│  │  • 纯值类型（i64, f64, 简单结构体）                                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                              ↓                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  堆分配 ARC（有开销，但最小化）                                       │   │
│  │  • 逃逸对象                                                           │   │
│  │  • 循环数据结构                                                       │   │
│  │  • 跨线程共享对象                                                     │   │
│  │  • 大型对象（> 64 字节）                                              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                              ↓                                               │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  GC 备份（解决循环引用）                                              │   │
│  │  • Weak Reference                                                    │   │
│  │  • 增量式 GC（分代收集）                                              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  开销对比：                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  分配方式    │  分配开销   │  访问开销   │  释放开销                 │   │
│  │  ──────────┼────────────┼────────────┼────────────────────────     │   │
│  │  栈分配     │  0 ns      │  0 ns      │  0 ns（自动）              │   │
│  │  ARC       │  2-5 ns    │  0 ns      │  2-5 ns                    │   │
│  │  GC        │  5-10 ns   │  1-2 ns    │  不确定（后台收集）        │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  设计原则：                                                                 │
│  1. 零开销抽象：不用不付                                                   │
│  2. 栈优先：逃逸分析决定分配位置                                           │
│  3. ARC 兜底：逃逸对象使用引用计数                                         │
│  4. GC 解决循环：Weak + 分代收集                                           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 逃逸分析

```rust
// src/middle/escape_analysis/mod.rs

/// 逃逸分析
///
/// 决定对象应该在栈上分配还是堆上分配
pub struct EscapeAnalyzer {
    /// 函数的局部变量信息
    local_vars: HashMap<LocalId, LocalInfo>,
    /// 调用图
    call_graph: CallGraph,
    /// 逃逸状态
    escape_state: EscapeState,
}

/// 局部变量信息
#[derive(Debug, Clone)]
struct LocalInfo {
    /// 变量类型
    ty: MonoType,
    /// 分配方式（栈/堆）
    allocation: Allocation,
    /// 是否逃逸
    escapes: bool,
    /// 被哪些闭包捕获
    captured_by: HashSet<ClosureId>,
    /// 是否被返回
    is_returned: bool,
    /// 是否被赋值给全局变量
    assigned_to_global: bool,
}

/// 分配方式
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Allocation {
    /// 栈分配
    Stack,
    /// 堆分配（Arc）
    Heap,
    /// 待确定
    Undecided,
}

/// 逃逸分析结果
#[derive(Debug, Clone)]
pub struct EscapeAnalysisResult {
    /// 栈分配的变量
    pub stack_allocated: HashSet<LocalId>,
    /// 堆分配的变量
    pub heap_allocated: HashSet<LocalId>,
    /// 需要创建闭包的环境
    pub closures: Vec<ClosureInfo>,
}

impl EscapeAnalyzer {
    /// 分析函数的逃逸情况
    pub fn analyze_function(&mut self, func: &FunctionIR) -> EscapeAnalysisResult {
        // 1. 收集所有局部变量
        self.collect_locals(func);

        // 2. 构建调用图
        self.build_call_graph(func);

        // 3. 标记明显的逃逸情况
        self.mark_obvious_escapes(func);

        // 5. 生成结果
        self.generate_result(func)
    }

    /// 标记明显的逃逸情况
    fn mark_obvious_escapes(&mut self, func: &FunctionIR) {
        for block in &func.blocks {
            for instr in &block.instructions {
                match instr {
                    Instruction::Ret(value) => {
                        // 返回值逃逸
                        if let Some(var) = self.get_variable(value) {
                            self.local_vars.get_mut(&var).unwrap().escapes = true;
                            self.local_vars.get_mut(&var).unwrap().is_returned = true;
                        }
                    }

                    Instruction::StoreGlobal { src, .. } => {
                        // 赋值给全局变量逃逸
                        if let Some(var) = self.get_variable(src) {
                            self.local_vars.get_mut(&var).unwrap().escapes = true;
                            self.local_vars.get_mut(&var).unwrap().assigned_to_global = true;
                        }
                    }

                    Instruction::MakeClosure { env, .. } => {
                        // 被闭包捕获逃逸
                        for var in &env.variables {
                            if let Some(info) = self.local_vars.get_mut(var) {
                                info.escapes = true;
                                info.captured_by.insert(env.closure_id);
                            }
                        }
                    }

                    _ => {}
                }
            }
        }
    }

    /// 传播逃逸状态
    fn propagate_escape(&mut self, func: &FunctionIR) {
        // 迭代传播，直到不动点
        let mut changed = true;
        while changed {
            changed = false;

            for block in &func.blocks {
                for instr in &block.instructions {
                    match instr {
                        Instruction::Call { args, .. } => {
                            // 函数调用可能使参数逃逸
                            for arg in args {
                                if let Some(var) = self.get_variable(arg) {
                                    let info = self.local_vars.get(&var).unwrap();
                                    if info.escapes {
                                        // 递归检查被调用函数的返回
                                        changed |= self.mark_callee_return_escapes(var);
                                    }
                                }
                            }
                        }

                        _ => {}
                    }
                }
            }
        }
    }

    /// 生成分析结果
    fn generate_result(&self, func: &FunctionIR) -> EscapeAnalysisResult {
        let mut stack_allocated = HashSet::new();
        let mut heap_allocated = HashSet::new();
        let mut closures = Vec::new();

        for (var_id, info) in &self.local_vars {
            if info.escapes || info.is_returned || info.assigned_to_global {
                // 逃逸的对象必须堆分配
                heap_allocated.insert(*var_id);
            } else if info.captured_by.is_empty() {
                // 不逃逸且不被捕获，栈分配
                stack_allocated.insert(*var_id);
            } else {
                // 被闭包捕获但不逃逸，可以栈分配但需要闭包包装
                heap_allocated.insert(*var_id);
                // 记录需要创建的闭包
                for closure_id in &info.captured_by {
                    closures.push(ClosureInfo {
                        id: *closure_id,
                        variables: vec![*var_id],
                    });
                }
            }
        }

        EscapeAnalysisResult {
            stack_allocated,
            heap_allocated,
            closures,
        }
    }
}
```

### 4.2 内存分配策略对比

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     内存分配策略对比                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     分配决策树                                       │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                      │   │
│  │                    ┌─────────────────┐                              │   │
│  │                    │  新建对象       │                              │   │
│  │                    └────────┬────────┘                              │   │
│  │                             │                                       │   │
│  │              ┌──────────────┼──────────────┐                        │   │
│  │              ▼              │              ▼                        │   │
│  │      ┌──────────────┐      │      ┌──────────────┐                 │   │
│  │      │ 是否逃逸？    │      │      │ 是否逃逸？    │                 │   │
│  │      └──────┬───────┘      │      └──────┬───────┘                 │   │
│  │             │              │             │                          │   │
│  │    ┌────────┴────────┐    │    ┌────────┴────────┐                │   │
│  │    ▼                 ▼    │    ▼                 ▼                │   │
│  │  是                否     │  是                否                 │   │
│  │    │                 │    │    │                 │                │   │
│  │    ▼                 ▼    │    ▼                 ▼                │   │
│  │  堆分配            栈分配  │  堆分配            栈分配             │   │
│  │  (Arc)             (StackAlloc)                                     │   │
│  │                                                                      │   │
│  │  + RefInc          零开销！    + RefInc        零开销！            │   │
│  │  + Release         仅移动SP    + Release       仅移动SP           │   │
│  │                                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                     性能对比                                         │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                      │   │
│  │  分配方式    │  分配开销   │  释放开销   │  适用场景                 │   │
│  │  ──────────┼────────────┼────────────┼────────────────────────     │   │
│  │  栈分配     │  1-2 ns    │  0 ns      │  不逃逸的局部对象           │   │
│  │  (StackAlloc)│  (移动SP)  │  (自动)    │  小型结构体                │   │
│  │             │             │            │                            │   │
│  │  堆分配     │  5-10 ns   │  1-2 ns    │  逃逸对象                  │   │
│  │  (HeapAlloc)│  (malloc)  │  (free)    │  需要共享所有权            │   │
│  │             │             │            │                            │   │
│  │  Arc 引用   │  2-5 ns    │  2-5 ns    │  线程安全共享              │   │
│  │  (MakeArc)  │  (原子操作) │  (原子操作)│                            │   │
│  │                                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 五、调用约定优化

### 5.1 三种调用方式

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     调用方式对比                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  1. CallStatic - 静态调用（最快）                                    │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                      │   │
│  │  指令: CallStatic func_addr, arg_count                               │   │
│  │                                                                      │   │
│  │  执行流程:                                                           │   │
│  │  ┌───────────────────────────────────────────────────────────────┐  │   │
│  │  │  1. 压栈参数 (按约定)                                           │  │   │
│  │  │  2. 直接跳转目标地址 (JMP)                                      │  │   │
│  │  │  3. 函数执行                                                    │  │   │
│  │  │  4. 返回值放入约定寄存器                                        │  │   │
│  │  └───────────────────────────────────────────────────────────────┘  │   │
│  │                                                                      │   │
│  │  开销: ~5-10 cycles (仅参数压栈 + 跳转)                             │   │
│  │  适用: 非虚函数、泛型特化函数、私有函数                              │   │
│  │                                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  2. CallVirt - 虚函数调用（次快）                                   │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                      │   │
│  │  指令: CallVirt obj_ptr, vtable_index, arg_count                    │   │
│  │                                                                      │   │
│  │  执行流程:                                                           │   │
│  │  ┌───────────────────────────────────────────────────────────────┐  │   │
│  │  │  1. 从 obj_ptr 读取 vtable 指针                                │  │   │
│  │  │  2. 从 vtable[vtable_index] 读取函数地址                       │  │   │
│  │  │  3. 跳转执行                                                    │  │   │
│  │  └───────────────────────────────────────────────────────────────┘  │   │
│  │                                                                      │   │
│  │  开销: ~10-20 cycles (一次内存读取)                                 │   │
│  │  适用: Trait 对象方法、override 函数                                │   │
│  │                                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  3. CallDyn - 动态调用（反射，首次慢后续快）                        │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                      │   │
│  │  指令: CallDyn method_name_offset, arg_count, ic_slot               │   │
│  │                                                                      │   │
│  │  执行流程 (首次):                                                    │   │
│  │  ┌───────────────────────────────────────────────────────────────┐  │   │
│  │  │  1. 从常量池加载方法名                                          │  │   │
│  │  │  2. 查 TypeMeta 找到方法（首次慢）                             │  │   │
│  │  │  3. 写入 IC Slot                                               │  │   │
│  │  │  4. 跳转执行                                                    │  │   │
│  │  │  总开销: ~1-10 μs                                               │  │   │
│  │  └───────────────────────────────────────────────────────────────┘  │   │
│  │                                                                      │   │
│  │  执行流程 (后续):                                                    │   │
│  │  ┌───────────────────────────────────────────────────────────────┐  │   │
│  │  │  1. 读取 receiver 类型 ID                                      │  │   │
│  │  │  2. 对比 IC Slot                                               │  │   │
│  │  │  3. 命中则直接跳转                                             │  │   │
│  │  │  总开销: ~5-10 ns (几乎零开销)                                 │  │   │
│  │  └───────────────────────────────────────────────────────────────┘  │   │
│  │                                                                      │   │
│  │  适用: 动态方法调用、插件系统                                        │   │
│  │                                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  调用方式选择策略                                                    │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                      │   │
│  │  在代码生成时，根据上下文选择最佳调用方式:                           │   │
│  │                                                                      │   │
│  │  ┌───────────────────────────────────────────────────────────────┐  │   │
│  │  │  if 函数是 final 或私有:        → CallStatic                 │  │   │
│  │  │  elif 函数在 vtable 中:         → CallVirt                   │  │   │
│  │  │  elif 使用反射 API 调用:        → CallDyn                    │  │   │
│  │  │  elif 无法静态确定类型:         → CallDyn                    │  │   │
│  │  │  else:                          → CallStatic                 │  │   │
│  │  └───────────────────────────────────────────────────────────────┘  │   │
│  │                                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 六、字节码格式设计

### 6.1 文件结构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         YaoXiang 字节码文件格式                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                         文件头 (32 字节)                             │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │  magic:        u32    = 0x59584243 ('YXBC')                      │   │
│  │  version:      u32    = 2 (字节码格式版本)                          │   │
│  │  flags:        u32    = 特性标志                                     │   │
│  │      bit 0:    has_reflection                                       │   │
│  │      bit 1:    has_debug_info                                       │   │
│  │      bit 2:    monomorphized      - 已单态化                        │   │
│  │  entry_point:  u32    = 入口函数偏移                                │   │
│  │  section_count: u16   = 节数量                                      │   │
│  │  file_size:    u32    = 文件总大小                                  │   │
│  │  checksum:     u32    = CRC32 校验                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      节表 (Section Table)                           │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │  每节一条记录：                                                       │   │
│  │    - id: u8 (节类型)                                                │   │
│  │    - offset: u32 (相对文件起始的偏移)                               │   │
│  │    - size: u32 (节大小)                                             │   │
│  │                                                                      │   │
│  │  节类型定义：                                                         │   │
│  │    0x01: CONST_POOL  (常量池)                                       │   │
│  │    0x02: TYPE_TABLE  (类型表)                                       │   │
│  │    0x03: CODE        (代码段)                                       │   │
│  │    0x04: DATA        (数据段)                                       │   │
│  │    0x05: VTABLE      (虚表)                                         │   │
│  │    0x10: DEBUG_INFO  (调试信息) [可选]                              │   │
│  │    0x11: INLINE_CACHE (内联缓存)                                    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      各节内容（按节表顺序）                          │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │                                                                      │   │
│  │  [常量池节 - 0x01]                                                   │   │
│  │  ConstPoolHeader                                                     │   │
│  │    const_count: u32                                                  │   │
│  │                                                                      │   │
│  │  [类型表节 - 0x02]                                                   │   │
│  │  TypeTableHeader                                                     │   │
│  │    type_count: u32                                                   │   │
│  │                                                                      │   │
│  │  [代码段节 - 0x03]                                                   │   │
│  │  FunctionHeader (每个函数一个)                                       │   │
│  │                                                                      │   │
│  │  ... 其他节                                                          │   │
│  │                                                                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  设计优点：                                                                 │
│  1. 节表结构支持增量更新                                                   │   │
│  2. CRC32 校验检测文件损坏                                                 │   │
│  3. 灵活扩展新节类型                                                       │   │
│  4. 可选的调试信息节（减少发布文件大小）                                    │   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 6.2 高性能指令集 (Typed Register-based ISA)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    二爻四象 · 42 - YaoXiang 字节码文件                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  「二爻四象」：                                                               │
│                                                                             │
│    ┌─────────────────────────────────────────────────────────────────┐     │
│    │   爻 = 阴阳 (2)                                                  │     │
│    │   象 = 四象 (4)                                                  │     │
│    │                                                                 │     │
│    │   二 × 四 = 8 → 八卦 / 64 卦象之源                              │     │
│    │                                                                 │     │
│    │   2 + 4 = 6 → 六十四卦                                          │     │
│    │                                                                 │     │
│    │   .42 = 我们的「答案」                                           │     │
│    └─────────────────────────────────────────────────────────────────┘     │
│                                                                             │
│  「42 - 生命、宇宙以及一切的终极答案」                                        │
│                                                                             │
│  文件命名示例：                                                              │
│    hello.yx      → hello.42     (编译后)                                   │
│    math.yx       → math.42                                              │
│    utils.yx      → utils.42                                             │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**设计理念**：
- **二爻**：阴阳两爻，代表语言的二元类型系统（值类型 vs 引用类型）
- **四象**：太阳、少阴、太阴、少阳，代表四种基本运算模式
- **42**：2 × 4 = 8，8 × 8 = 64（周易六十四卦），同时致敬《银河系漫游指南》

> 「道生一，一生二，二生三，三生万物。」
> `.42` 文件承载的不仅是字节码，更是东方哲学与现代计算的交融。

### 6.2 高性能指令集 (Typed Register-based ISA)

```rust
// src/vm/opcode.rs

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum Opcode {
    // =====================
    // 基础控制流
    // =====================
    Nop = 0x00,
    Return,         // 返回 (void)
    ReturnValue,    // 返回值 (reg)
    Jmp(i32),       // 相对跳转
    JmpIf(u8, i32), // 条件跳转 (reg, offset)

    // =====================
    // 栈与寄存器操作
    // =====================
    Move(u8, u8),   // 寄存器移动 dst, src
    LoadConst(u8, u16), // 加载常量 dst, const_idx

    // =====================
    // 整数运算 (I32) - 内存优化场景
    // =====================
    I32Add(u8, u8, u8), // dst, src1, src2
    I32Sub(u8, u8, u8),
    I32Mul(u8, u8, u8),
    I32Div(u8, u8, u8),
    I32Rem(u8, u8, u8),
    I32And(u8, u8, u8),
    I32Or(u8, u8, u8),
    I32Xor(u8, u8, u8),
    I32Shl(u8, u8, u8),
    I32Shr(u8, u8, u8),
    I32Sar(u8, u8, u8),
    I32Load(u8, u8, i16),   // dst, base, offset
    I32Store(u8, u8, i16),  // src, base, offset

    // =====================
    // 整数运算 (I64) - 主要整数类型
    // =====================
    I64Add(u8, u8, u8),
    I64Sub(u8, u8, u8),
    I64Mul(u8, u8, u8),
    I64Div(u8, u8, u8),
    I64Rem(u8, u8, u8),
    I64And(u8, u8, u8),
    I64Or(u8, u8, u8),
    I64Xor(u8, u8, u8),
    I64Shl(u8, u8, u8),
    I64Sar(u8, u8, u8),
    I64Shr(u8, u8, u8),
    I64Load(u8, u8, i16),   // dst, base, offset
    I64Store(u8, u8, i16),  // src, base, offset

    // =====================
    // 浮点运算 (F32) - 图形/科学计算
    // =====================
    F32Add(u8, u8, u8),
    F32Sub(u8, u8, u8),
    F32Mul(u8, u8, u8),
    F32Div(u8, u8, u8),
    F32Rem(u8, u8, u8),
    F32Sqrt(u8, u8),
    F32Load(u8, u8, i16),   // dst, base, offset
    F32Store(u8, u8, i16),  // src, base, offset

    // =====================
    // 浮点运算 (F64) - 主要浮点类型
    // =====================
    F64Add(u8, u8, u8),
    F64Sub(u8, u8, u8),
    F64Mul(u8, u8, u8),
    F64Div(u8, u8, u8),
    F64Rem(u8, u8, u8),
    F64Sqrt(u8, u8),
    F64Load(u8, u8, i16),   // dst, base, offset
    F64Store(u8, u8, i16),  // src, base, offset

    // =====================
    // 比较指令
    // =====================
    I64Cmp(u8, u8, u8),  // dst, src1, src2 (-1/0/1)
    F64Cmp(u8, u8, u8),
    I64Eq(u8, u8, u8),
    I64Ne(u8, u8, u8),
    I64Lt(u8, u8, u8),
    I64Le(u8, u8, u8),
    I64Gt(u8, u8, u8),
    I64Ge(u8, u8, u8),
    F64Eq(u8, u8, u8),
    F64Ne(u8, u8, u8),
    F64Lt(u8, u8, u8),
    F64Le(u8, u8, u8),
    F64Gt(u8, u8, u8),
    F64Ge(u8, u8, u8),

    // =====================
    // 内存与对象模型 (无 GC 核心)
    // =====================
    /// 栈上分配结构体 (值类型优化)
    /// size 由编译期确定，无需操作数，直接移动栈指针
    StackAlloc(u16),

    /// 堆分配 (引用类型)
    HeapAlloc(u8, u16), // dst, type_id

    /// 引用计数增加 (原子/非原子由编译器决定使用不同指令)
    Retain(u8),

    /// 引用计数减少 (为0时析构)
    Release(u8),

    /// 读取字段 (静态偏移，极快)
    /// dst, obj, offset
    GetField(u8, u8, u16),

    /// 写入字段
    SetField(u8, u8, u16),

    // =====================
    // 函数调用优化
    // =====================
    /// 静态分发 (最快，类似 C++ 普通函数调用)
    /// dst, func_id, base_arg_reg, arg_count
    CallStatic(u8, u32, u8, u8),

    /// 虚表分发 (Trait 对象调用，类似 C++ 虚函数)
    /// dst, obj_reg, vtable_idx, base_arg_reg, arg_count
    CallVirt(u8, u8, u16, u8, u8),

    /// 动态分发 (反射调用，带内联缓存)
    /// dst, obj_reg, name_idx, base_arg_reg, arg_count
    CallDyn(u8, u8, u16, u8, u8),

    /// 尾调用优化
    TailCall(u32, u8, u8),

    // =====================
    // 模式匹配优化 (Switch)
    // =====================
    /// 多路分支跳转 (O(1))
    /// reg: 匹配值, default_offset: 默认跳转, table_idx: 跳转表索引
    Switch(u8, i32, u16),

    // =====================
    // 循环优化 (Iterator Elimination)
    // =====================
    /// 范围循环初始化
    /// start, end, step, exit_offset
    LoopStart(u8, u8, u8, i32),
    /// 循环递增与跳转
    /// current, step, loop_start_offset
    LoopInc(u8, u8, i32),

    // =====================
    // 闭包与 Upvalue
    // =====================
    /// 创建闭包
    /// dst, func_id, upvalue_count
    MakeClosure(u8, u32, u8),
    /// 加载 Upvalue
    LoadUpvalue(u8, u8), // dst, upvalue_idx
    /// 存储 Upvalue
    StoreUpvalue(u8, u8), // src, upvalue_idx
    /// 关闭 Upvalue (搬迁栈上变量到堆)
    CloseUpvalue(u8), // reg

    // =====================
    // 集合与字符串优化
    // =====================
    /// 预分配容量的列表创建
    NewListWithCap(u8, u16), // dst, capacity

    // =====================
    // 字符串操作
    // =====================
    StringLength(u8, u8),          // dst, src
    StringGetChar(u8, u8, u8),     // dst, src, index
    StringConcat(u8, u8, u8),      // dst, str1, str2
    StringFromInt(u8, u8),         // dst, int_reg
    StringFromFloat(u8, u8),       // dst, float_reg
    StringEqual(u8, u8, u8),       // dst, str1, str2 (bool)

    // =====================
    // 边界检查（调试模式）
    // =====================
    BoundsCheck(u8, u8, u8),       // dst, array_reg, index

    // =====================
    // 异常处理
    // =====================
    TryBegin(u16),                 // catch_offset
    TryEnd,
    Throw(u8),                     // exception_reg
    Rethrow,

    // =====================
    // 异步原语 (M:N 调度)
    // =====================
    /// 主动让出执行权
    Yield,
    /// 等待 Future
    Await(u8), // future_reg
    /// 创建异步任务
    Spawn(u8, u8), // dst, closure_reg

    // =====================
    // 反射与元数据
    // =====================
    /// 获取类型元数据对象 (懒加载)
    /// 如果元数据未加载，触发加载；否则直接返回缓存的 TypeObject 指针
    TypeOf(u8, u16), // dst, type_id

    // 保留 (0xF0 - 0xFF)
    Custom0 = 0xF0,
    Custom1 = 0xF1,
    Custom2 = 0xF2,
    Custom3 = 0xF3,
    Custom4 = 0xF4,
    Custom5 = 0xF5,
    Custom6 = 0xF6,
    Custom7 = 0xF7,
    Custom8 = 0xF8,
    Custom9 = 0xF9,
}
```

---

## 七、实现步骤规划

### 7.1 第 6 周：类型化指令与单态化

| 任务 | 文件 | 输出 | 验收标准 |
|------|------|------|----------|
| 单态化编译器 | `src/middle/monomorphize/mod.rs` | Monomorphizer | 泛型展开正确 |
| 逃逸分析 | `src/middle/escape_analysis/mod.rs` | EscapeAnalyzer | 栈/堆分配正确 |
| 定义 Opcode | `src/vm/opcode.rs` | Opcode 枚举 | 指令集完整 |
| 基础代码生成 | `src/middle/codegen/mod.rs` | CodegenContext | I64/F64 指令正确 |
| 单元测试 | `tests/unit/codegen.rs` | 测试用例 | 80%+ 覆盖 |

### 7.2 第 7 周：内存管理与反射

| 任务 | 文件 | 输出 | 验收标准 |
|------|------|------|----------|
| 内联缓存 | `src/vm/inline_cache.rs` | InlineCacheManager | 缓存命中正确 |
| 生命周期分析 | `src/middle/lifetime/mod.rs` | Retain/Release 插入 | 内存正确释放 |
| Switch 指令 | `src/middle/codegen/switch.rs` | 查表跳转 | O(1) 匹配 |
| LoopStart/LoopInc | `src/middle/codegen/loop.rs` | 循环优化 | 迭代器消除 |
| 闭包生成 | `src/middle/codegen/closure.rs` | MakeClosure/Upvalue | 闭包正确 |
| 字节码序列化 | `src/middle/codegen/bytecode.rs` | BytecodeFile | 可反序列化 |
| 集成测试 | `tests/integration/codegen.rs` | 完整模块测试 | 测试通过 |

---

## 八、验收标准 (性能导向)

### 8.1 功能验收

| 测试项 | 标准 |
|--------|------|
| 单态化 | 泛型函数展开为具体类型 |
| 类型化指令 | I32/I64/F32/F64 指令生成正确 |
| 逃逸分析 | 栈分配/堆分配决策正确 |
| 字节码序列化 | 可序列化和反序列化，支持 CRC32 校验 |
| 内联缓存 | 反射调用首次慢后续快 |
| 模式匹配 | Switch 指令 O(1) 跳转 |
| 循环优化 | LoopStart/LoopInc 替代迭代器 |
| 字符串操作 | StringLength/StringConcat 指令正确 |
| 异常处理 | TryBegin/TryEnd/Throw 指令正确 |

### 8.2 性能验收

| 测试项 | 标准 |
|--------|------|
| 编译速度 | 1000 行代码 < 1 秒 |
| 字节码大小 | <= 源文件大小的 5 倍 |
| 静态调用开销 | ~5-10 cycles |
| ARC 分配 | 2-5 ns |
| ARC 释放 | 2-5 ns |
| 栈分配 | 零分配开销 |
| 斐波那契 | 达到 Python 的 10-20 倍 |

### 8.3 质量验收

| 测试项 | 标准 |
|--------|------|
| 代码覆盖率 | >= 80% |
| 文档完整性 | 每个公共 API 有文档 |
| 测试通过率 | 100% 通过 |
| 指令覆盖率 | I32/I64/F32/F64/String/Exception 指令完整 |

---

## 九、代码生成器架构

### 9.1 编译管线

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           编译管线                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  源码 (.yx)                                                                 │
│      │                                                                        │
│      ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  1. 词法分析 (Lexer)                                                 │   │
│  │     输出: Token 流                                                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│      │                                                                        │
│      ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  2. 语法分析 (Parser)                                                │   │
│  │     输出: AST                                                        │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│      │                                                                        │
│      ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  3. 类型检查 (TypeChecker)                                           │   │
│  │     输出: 类型推断后的 AST                                            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│      │                                                                        │
│      ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  4. 单态化 (Monomorphizer) [新增]                                    │   │
│  │     泛型展开: List<T> → List_int, List_float                         │   │
│  │     输出: 具体类型的 IR                                              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│      │                                                                        │
│      ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  5. 逃逸分析 (EscapeAnalyzer) [新增]                                 │   │
│  │     决定栈分配/堆分配                                                 │   │
│  │     输出: 带分配信息的 IR                                            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│      │                                                                        │
│      ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  6. 生命周期分析 (LifetimeAnalyzer) [新增]                          │   │
│  │     自动插入 Retain/Release                                          │   │
│  │     输出: 带引用计数指令的 IR                                        │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│      │                                                                        │
│      ▼                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  7. 代码生成 (CodeGenerator)                                         │   │
│  │     生成类型化字节码                                                  │   │
│  │     输出: BytecodeFile                                               │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│      │                                                                        │
│      ▼                                                                        │
│  字节码 (.42)                                                             │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 9.2 示例：加法函数

**源码：**
```yaoxiang
add(a: Int, b: Int) -> Int = (a, b) => a + b
```

**字节码：**
```asm
; 函数签名已确定参数为 i64
.LoopStart r0, r1, r1, .exit  ; 初始化循环
I64Load r2, r0                ; 加载 a
I64Load r3, r1                ; 加载 b
I64Add r4, r2, r3             ; 直接映射到 CPU 指令，极快！
Ret r4
.exit:
```

---

## 十、详细代码生成示例

### 10.1 表达式代码生成

```rust
// src/middle/codegen/expr.rs

impl<'a> CodegenContext<'a> {
    /// 生成表达式
    pub fn generate_expr(&mut self, expr: &Expr) -> Result<Operand, CodegenError> {
        match expr {
            Expr::Lit(literal, _) => self.generate_literal(literal),
            Expr::Var(name, span) => self.generate_variable(name, *span),
            Expr::BinOp { op, left, right, .. } => self.generate_binop(op, left, right),
            Expr::UnOp { op, expr, .. } => self.generate_unop(op, expr),
            Expr::Call { func, args, .. } => self.generate_call(func, args),
            Expr::If { condition, then_branch, elif_branches, else_branch, .. } => {
                self.generate_if(condition, then_branch, elif_branches, else_branch)
            }
            Expr::While { condition, body, label, .. } => {
                self.generate_while(condition, body, label.as_deref())
            }
            Expr::For { var, iterable, body, .. } => self.generate_for(var, iterable, body),
            Expr::Match { expr, arms, .. } => self.generate_match(expr, arms),
            Expr::Block(block) => self.generate_block(block),
            Expr::Return(value, _) => self.generate_return(value.as_ref()),
            Expr::Break(label, _) => self.generate_break(label.as_deref()),
            Expr::Continue(label, _) => self.generate_continue(label.as_deref()),
            Expr::Tuple(exprs, _) => self.generate_tuple(exprs),
            Expr::List(exprs, _) => self.generate_list(exprs),
            Expr::Dict(pairs, _) => self.generate_dict(pairs),
            Expr::Cast { expr, target_type, .. } => self.generate_cast(expr, target_type),
            Expr::FieldAccess { expr, field, .. } => self.generate_field_access(expr, field),
            Expr::Index { expr, index, .. } => self.generate_index(expr, index),
            Expr::FnDef { .. } => Err(CodegenError::UnimplementedExpr {
                expr_type: "FnDef".to_string(),
            }),
        }
    }

    /// 生成字面量
    fn generate_literal(&mut self, literal: &Literal) -> Result<Operand, CodegenError> {
        let const_index = self.add_constant(literal_to_const_value(literal));
        Ok(Operand::Const(const_index))
    }

    /// 生成二元运算（类型化指令）
    fn generate_binop(&mut self, op: &BinOp, left: &Expr, right: &Expr) -> Result<Operand, CodegenError> {
        let dst = self.next_temp();
        let lhs = self.generate_expr(left)?;
        let rhs = self.generate_expr(right)?;

        // 根据操作符和类型选择类型化指令
        let instr = match op {
            BinOp::Add => Instruction::I64Add(dst, lhs, rhs),
            BinOp::Sub => Instruction::I64Sub(dst, lhs, rhs),
            BinOp::Mul => Instruction::I64Mul(dst, lhs, rhs),
            BinOp::Div => Instruction::I64Div(dst, lhs, rhs),
            BinOp::Mod => Instruction::I64Rem(dst, lhs, rhs),
            BinOp::Eq => Instruction::I64Eq(dst, lhs, rhs),
            BinOp::Neq => Instruction::I64Ne(dst, lhs, rhs),
            BinOp::Lt => Instruction::I64Lt(dst, lhs, rhs),
            BinOp::Le => Instruction::I64Le(dst, lhs, rhs),
            BinOp::Gt => Instruction::I64Gt(dst, lhs, rhs),
            BinOp::Ge => Instruction::I64Ge(dst, lhs, rhs),
            BinOp::And | BinOp::Or => {
                // 短路求值需要控制流
                return self.generate_short_circuit(op, left, right);
            }
            BinOp::Assign => {
                return self.generate_assignment(left, right);
            }
            BinOp::Range => {
                return self.generate_range(lhs, rhs);
            }
        };

        self.emit(instr);
        Ok(dst)
    }
}
```

### 10.2 语句代码生成

```rust
// src/middle/codegen/stmt.rs

impl<'a> CodegenContext<'a> {
    /// 生成语句
    pub fn generate_stmt(&mut self, stmt: &Stmt) -> Result<(), CodegenError> {
        match &stmt.kind {
            StmtKind::Expr(expr) => {
                self.generate_expr(expr)?;
                Ok(())
            }
            StmtKind::Var { name, type_annotation, initializer, is_mut } => {
                self.generate_var_decl(name, type_annotation.as_ref(), initializer.as_ref(), *is_mut)
            }
            StmtKind::For { var, iterable, body, label } => {
                self.generate_for_stmt(var, iterable, body, label.as_deref())
            }
            StmtKind::TypeDef { name, definition } => {
                self.generate_type_def(name, definition)
            }
            StmtKind::Module { name, items } => {
                self.generate_module(name, items)
            }
            StmtKind::Use { .. } => {
                // use 语句在编译时处理
                Ok(())
            }
        }
    }

    /// 生成变量声明（带逃逸分析）
    fn generate_var_decl(
        &mut self,
        name: &str,
        type_annotation: Option<&Type>,
        initializer: Option<&Expr>,
        is_mut: bool,
    ) -> Result<(), CodegenError> {
        let local_index = self.next_local();

        // 如果有初始化表达式，生成它
        if let Some(init) = initializer {
            let src = self.generate_expr(init)?;

            // 根据逃逸分析决定分配方式
            let should_heap_allocate = self.escape_analysis.should_heap_allocate(name);

            if should_heap_allocate {
                // 堆分配：HeapAlloc + Retain
                self.emit(Instruction::HeapAlloc(local_index, self.get_type_id(type_annotation)));
                self.emit(Instruction::Retain(Operand::Local(local_index)));
            } else {
                // 栈分配：StackAlloc
                let size = self.get_type_size(type_annotation);
                self.emit(Instruction::StackAlloc(size));
            }

            // 存储初始化值
            self.emit(Instruction::Store {
                dst: Operand::Local(local_index),
                src,
            });
        }

        // 注册符号
        let ty = self.resolve_type(type_annotation, initializer)?;
        self.symbol_table.insert(name.to_string(), Symbol {
            name: name.to_string(),
            ty,
            storage: Storage::Local(local_index),
            is_mut,
            scope_level: self.current_scope_level(),
        });

        Ok(())
    }

    /// 生成 for 循环（使用 LoopStart/LoopInc）
    fn generate_for_stmt(
        &mut self,
        var: &str,
        iterable: &Expr,
        body: &Block,
        label: Option<&str>,
    ) -> Result<(), CodegenError> {
        let loop_label = self.next_label();
        let end_label = self.next_label();

        // 保存循环标签（用于 break/continue）
        let prev_label = self.current_loop_label.replace((loop_label, end_label));

        // 生成 iterable 表达式
        let iterable_operand = self.generate_expr(iterable)?;

        // 检查是否是范围循环 (0..n)
        if let Some(range_info) = self.detect_range_loop(var, iterable) {
            // 优化：直接使用 LoopStart/LoopInc
            self.emit(Instruction::LoopStart(
                range_info.start,
                range_info.end,
                range_info.step,
                end_label,
            ));

            // 生成循环体
            self.generate_block(body)?;

            // 循环递增
            self.emit(Instruction::LoopInc(
                range_info.current,
                range_info.step,
                loop_label,
            ));
        } else {
            // 通用迭代器循环
            self.generate_iterator_loop(var, iterable_operand, body, loop_label, end_label)?;
        }

        // 恢复标签
        self.current_loop_label = prev_label;

        Ok(())
    }
}
```

### 10.3 控制流生成

```rust
// src/middle/codegen/control_flow.rs

impl<'a> CodegenContext<'a> {
    /// 生成 if 表达式
    fn generate_if(
        &mut self,
        condition: &Expr,
        then_branch: &Block,
        elif_branches: &[(Expr, Block)],
        else_branch: Option<&Box<Block>>,
    ) -> Result<Operand, CodegenError> {
        let end_label = self.next_label();
        let mut current_else = else_branch;

        // 编译条件
        let cond = self.generate_expr(condition)?;

        // 生成 then 分支
        let then_label = self.next_label();
        self.emit(Instruction::JmpIfNot(cond, then_label));
        self.enter_block(then_label);
        let then_result = self.generate_block(then_branch)?;
        self.emit(Instruction::Jmp(end_label));
        self.exit_block();

        // 处理 elif 分支
        for (elif_cond, elif_body) in elif_branches {
            let elif_label = self.next_label();
            self.emit(Instruction::JmpIfNot(cond, elif_label));
            self.enter_block(elif_label);
            let _ = self.generate_block(elif_body)?;
            self.emit(Instruction::Jmp(end_label));
            self.exit_block();
        }

        // 生成 else 分支
        if let Some(else_block) = current_else {
            self.enter_block(end_label);
            let else_result = self.generate_block(else_block)?;
            self.exit_block();
            Ok(else_result)
        } else {
            // 无 else 分支，返回 void
            self.enter_block(end_label);
            self.exit_block();
            Ok(Operand::Const(self.void_index))
        }
    }

    /// 生成 while 循环
    fn generate_while(
        &mut self,
        condition: &Expr,
        body: &Block,
        label: Option<&str>,
    ) -> Result<Operand, CodegenError> {
        let loop_label = self.next_label();
        let end_label = self.next_label();

        // 保存循环标签（用于 break/continue）
        let prev_label = self.current_loop_label.replace((loop_label, end_label));

        // 循环开始
        self.emit(Instruction::Label(loop_label));

        // 编译条件
        let cond = self.generate_expr(condition)?;

        // 条件为假跳出循环
        self.emit(Instruction::JmpIfNot(cond, end_label));

        // 保存当前作用域
        let prev_scope = self.symbol_table.push_scope();

        // 生成循环体
        self.generate_block(body)?;

        // 恢复作用域
        self.symbol_table.pop_scope(prev_scope);

        // 跳回循环开始
        self.emit(Instruction::Jmp(loop_label));

        // 循环结束
        self.emit(Instruction::Label(end_label));

        // 恢复标签
        self.current_loop_label = prev_label;

        Ok(Operand::Const(self.void_index))
    }

    /// 生成 match 表达式（使用 Switch）
    fn generate_match(&mut self, expr: &Expr, arms: &[MatchArm]) -> Result<Operand, CodegenError> {
        let expr_operand = self.generate_expr(expr)?;
        let end_label = self.next_label();
        let mut result = self.next_temp();

        // 检查是否可以使用 Switch（整数枚举）
        if let Some(switch_info) = self.can_use_switch(expr_operand.clone(), arms) {
            // 使用 Switch 指令（O(1) 跳转）
            self.emit(Instruction::Switch(
                expr_operand,
                end_label,
                switch_info.table_index,
            ));

            // 为每个臂生成代码
            for (i, arm) in arms.iter().enumerate() {
                let arm_label = self.next_label();

                // 写入跳转表条目
                self.jump_table.add_entry(switch_info.table_index, i, arm_label);

                // 进入该臂的基本块
                self.enter_block(arm_label);
                let prev_scope = self.symbol_table.push_scope();
                self.bind_pattern_variables(&arm.pattern, &expr_operand)?;
                let arm_result = self.generate_expr(&arm.body)?;
                result = arm_result;
                self.symbol_table.pop_scope(prev_scope);
                self.emit(Instruction::Jmp(end_label));
                self.exit_block();
            }

            self.emit(Instruction::Label(end_label));
            return Ok(result);
        }

        // 回退到普通 if-else 链
        for arm in arms {
            let arm_label = self.next_label();

            // 生成模式匹配条件
            let matches = self.generate_pattern_match(&expr_operand, &arm.pattern)?;

            self.emit(Instruction::JmpIfNot(matches, arm_label));
            self.enter_block(arm_label);
            let prev_scope = self.symbol_table.push_scope();
            self.bind_pattern_variables(&arm.pattern, &expr_operand)?;
            let arm_result = self.generate_expr(&arm.body)?;
            result = arm_result;
            self.symbol_table.pop_scope(prev_scope);
            self.emit(Instruction::Jmp(end_label));
            self.exit_block();
        }

        self.emit(Instruction::Label(end_label));
        Ok(result)
    }
}
```

---

## 十一、测试策略

### 11.1 测试用例

```rust
// tests/unit/codegen.rs

#[test]
fn test_integer_arithmetic() {
    let code = r#"
        add(a: Int, b: Int) -> Int = (a, b) => a + b
        sub(a: Int, b: Int) -> Int = (a, b) => a - b
        mul(a: Int, b: Int) -> Int = (a, b) => a * b
    "#;

    let bytecode = compile(code).unwrap();

    // 验证 I64Add 指令存在
    assert!(bytecode.code.iter().any(|instr| instr.opcode == Opcode::I64Add));
    assert!(bytecode.code.iter().any(|instr| instr.opcode == Opcode::I64Sub));
    assert!(bytecode.code.iter().any(|instr| instr.opcode == Opcode::I64Mul));
}

#[test]
fn test_floating_point_arithmetic() {
    let code = r#"
        add(a: Float, b: Float) -> Float = (a, b) => a + b
        mul(a: Float, b: Float) -> Float = (a, b) => a * b
    "#;

    let bytecode = compile(code).unwrap();

    // 验证 F64Add 指令存在
    assert!(bytecode.code.iter().any(|instr| instr.opcode == Opcode::F64Add));
    assert!(bytecode.code.iter().any(|instr| instr.opcode == Opcode::F64Mul));
}

#[test]
fn test_comparison() {
    let code = r#"
        cmp(a: Int, b: Int) -> Bool = (a, b) => a < b
    "#;

    let bytecode = compile(code).unwrap();
    assert!(bytecode.code.iter().any(|instr| instr.opcode == Opcode::I64Lt));
}

#[test]
fn test_loop_optimization() {
    let code = r#"
        sum(n: Int) -> Int = (n) => {
            total = 0
            i = 0
            while i < n {
                total = total + i
                i = i + 1
            }
            total
        }
    "#;

    let bytecode = compile(code).unwrap();

    // 验证循环优化指令
    let iterator_calls: Vec<_> = bytecode.code.iter()
        .filter(|i| matches!(i.opcode, Opcode::CallStatic))
        .collect();

    assert!(iterator_calls.is_empty(), "循环应该被优化，没有迭代器开销");
}

#[test]
fn test_switch_instruction() {
    let code = r#"
        value: Int = 2
        result: String = match value {
            0 => "zero"
            1 => "one"
            2 => "two"
            _ => "other"
        }
    "#;

    let bytecode = compile(code).unwrap();

    // 验证 Switch 指令
    assert!(bytecode.code.iter().any(|instr| instr.opcode == Opcode::Switch));
}

#[test]
fn test_closure_capture() {
    let code = r#"
        make_adder(addend: Int) -> (Int) -> Int = (addend) => {
            (x: Int) => x + addend
        }
    "#;

    let bytecode = compile(code).unwrap();

    // 验证闭包相关指令
    assert!(bytecode.code.iter().any(|instr| instr.opcode == Opcode::MakeClosure));
    assert!(bytecode.code.iter().any(|instr| instr.opcode == Opcode::LoadUpvalue));
}
```

### 11.2 性能测试

```rust
// benches/codegen.rs

use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn compile_and_benchmark(code: &str) {
    let bytecode = compile(code).unwrap();
    assert!(bytecode.code.len() > 0);
}

fn criterion_benchmark(c: &mut Criterion) {
    c.bench_function("compile simple add", |b| {
        let code = r#"
            add(a: Int, b: Int) -> Int = (a, b) => a + b
        "#;
        b.iter(|| compile_and_benchmark(black_box(code)))
    });

    c.bench_function("compile fibonacci", |b| {
        let code = r#"
            fib(n: Int) -> Int = (n) => {
                if n < 2 { n } else { fib(n - 1) + fib(n - 2) }
            }
        "#;
        b.iter(|| compile_and_benchmark(black_box(code)))
    });

    c.bench_function("compile loop", |b| {
        let code = r#"
            sum(n: Int) -> Int = (n) => {
                total = 0
                i = 0
                while i < n {
                    total = total + i
                    i = i + 1
                }
                total
            }
        "#;
        b.iter(|| compile_and_benchmark(black_box(code)))
    });
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
```

---

## 十二、常见问题与解决方案

### 12.1 单态化膨胀

**问题**：泛型函数可能导致代码膨胀

**缓解策略**：
```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        单态化策略与缓解机制                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  策略 1：按需单态化                                                         │
│  只对实际调用的类型组合生成代码                                              │
│  - 优点：减少未使用的特化                                                    │
│  - 缺点：首次调用需要编译                                                    │
│                                                                             │
│  策略 2：代码共享                                                           │
│  相同的类型组合共享一份代码                                                  │
│  - 优点：避免重复                                                            │
│                                                                             │
│  策略 3：内联缓存优化小集合                                                  │
│  对于少量类型的调用，使用单一入口和分支                                      │
│  - 优点：平衡代码大小和性能                                                  │
│                                                                             │
│  策略 4：阈值控制                                                            │
│  - 单函数特化数量上限：16                                                    │
│  - 超过阈值回退到动态分发                                                    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**实现**：
```rust
// 按需特化，而非全部特化
pub struct Monomorphizer {
    /// 已实例化的函数
    instantiated: HashSet<FunctionKey>,
    /// 实例化请求队列
    pending: Vec<FunctionKey>,
    /// 单函数特化数量上限
    specialization_limit: usize,
}

impl Monomorphizer {
    /// 检查是否应该特化
    fn should_specialize(&self, func: &FunctionKey) -> bool {
        let count = self.instantiated
            .iter()
            .filter(|k| k.base_name == func.base_name)
            .count();
        count < self.specialization_limit
    }
}
```

### 12.2 内联缓存失效

**问题**：类型变化导致缓存失效

**解决方案**：使用分层缓存（Monomorphic → Polymorphic → Megamorphic）

---

## 十三、总结

### 13.1 设计目标达成

| 设计目标 | 实现方式 | 达成状态 |
|----------|----------|----------|
| 接近 Rust 性能 | 类型化指令 + 单态化 + 栈分配 | ✅ |
| 零成本抽象 | 泛型编译期展开 | ✅ |
| 零成本反射 | 懒加载 + 内联缓存 | ✅ |
| 无 GC | 引用计数 + 栈分配 | ✅ |
| 完整反射支持 | TypeMetadata + CallDyn | ✅ |

### 13.2 下一步

- **阶段六**：字节码虚拟机实现
- **阶段七**：运行时系统
- **阶段八**：测试与优化

---

> 「工欲善其事，必先利其器。」
>
> 阶段五的实现将为后续虚拟机执行奠定高性能基础。类型化指令消除运行时分发，内联缓存实现零开销反射，栈分配消除 GC 压力——这些设计共同指向一个目标：**接近 Rust 的性能，更好的开发体验**。
