# 接口类型直接赋值与编译期优化实现计划

> **状态**: 实施中
> **创建日期**: 2026-02-20
> **相关 RFC**: [RFC-010 统一类型语法](../design/accepted/010-unified-type-syntax.md), [RFC-011 泛型系统](../design/accepted/011-generic-type-system.md), [约束设计决策](./completed/constraint-design.md)

---

## 一、概述

### 1.1 目标

重新实现接口（约束）类型的直接赋值语法，并实现编译期优化以消除 vtable 开销：

1. **支持直接接口赋值**：`d: Drawable = Circle(1)`
2. **编译期类型推断**：尽可能确定具体类型
3. **零开销优化**：具体类型确定时使用直接调用
4. **vtable 兜底**：无法确定具体类型时使用 vtable

### 1.2 当前状态

| 功能 | 状态 |
|------|------|
| vtable 运行时实现 | ✅ 已实现 |
| 虚方法调用 IR | ✅ 已实现 |
| 泛型约束 `[T: Drawable]` | ✅ 已实现 |
| 直接接口赋值 `s: Drawable = point` | ❌ 被拒绝 |

### 1.3 设计变更

**变更前**：
```yaoxiang
d: Drawable = Circle(1)  # ❌ 编译错误
```

**变更后**：
```yaoxiang
d: Drawable = Circle(1)  # ✅ 允许

# 编译期推断：
# - Circle 是具体类型且可确定 → 直接调用（零开销）
# - 类型不可确定 → 使用 vtable
```

---

## 二、分阶段实施计划

### 阶段 1：修改设计文档

#### 1.1.1 修改 constraint-design.md

**文件**: `docs/src/reference/plan/completed/constraint-design.md`

**修改内容**:
1. 移除"约束只能在泛型上下文中使用"的限制
2. 添加直接接口赋值语法支持
3. 添加编译期优化策略说明

**验收方式**:
- [ ] 文档更新完成
- [ ] 新语法示例完整
- [ ] 优化策略描述清晰

#### 1.1.2 更新 RFC-010（如需要）

**检查项**:
- [ ] 接口赋值语法与文档一致

---

### 阶段 2：修改编译器类型检查

#### 2.1.1 移除约束类型检查限制

**文件**: `src/frontend/typecheck/checking/assignment.rs`

**实现目标**:
- 移除拒绝约束类型赋值的检查逻辑
- 允许 `d: Drawable = Circle(1)` 语法通过类型检查

**验收方式**:
- [ ] `d: Drawable = Circle(1)` 不再报 "constraint_not_in_generic" 错误
- [ ] 编译通过

**相关测试**:
| 测试名称 | 测试代码 | 预期结果 |
|----------|----------|----------|
| 接口赋值基本语法 | `d: Drawable = Circle(1)` | ✅ 编译通过 |
| 接口赋值泛型参数 | `f: [T: Drawable](T) -> Void = ...` | ✅ 继续工作 |

---

### 阶段 3：实现约束类型子类型检查

#### 3.1.1 实现约束协变检查

**文件**: `src/frontend/typecheck/checking/subtyping.rs`

**实现目标**:
- 实现具体类型对约束类型的子类型检查
- 验证具体类型是否满足约束的所有方法要求
- 实现结构化子类型规则

**验收方式**:
- [ ] 子类型检查支持约束类型
- [ ] 结构化匹配规则正确实现
- [ ] 方法签名兼容性检查正确

**相关测试**:
| 测试名称 | 测试代码 | 预期结果 |
|----------|----------|----------|
| 结构子类型匹配 | `d: Drawable = Point{draw: fn, ...}` | ✅ 通过 |
| 方法缺失 | `d: Drawable = Rect{...}` | ❌ 错误：缺少 draw |
| 方法签名不匹配 | `d: Drawable = Bad{draw: (Int) -> Void}` | ❌ 错误：签名不匹配 |
| 多方法约束 | `d: Serializable = Point{serialize: fn, ...}` | ✅ 通过 |

---

### 阶段 4：实现编译期类型推断优化

#### 4.1.1 类型推断信息传递

**实现目标**:
- 类型检查时推断变量的具体类型
- 区分"可确定具体类型"和"无法确定类型"
- 推断结果传递到 IR 生成阶段

**推断逻辑**:

| 场景 | 推断结果 | 调用方式 |
|------|----------|----------|
| `d: Drawable = Circle(1)` | 具体类型 Circle | 直接调用 |
| `d: Drawable = get_shape()` | 未知 | vtable |
| `shapes: List[Drawable] = [...]` | 异构 | vtable |

**验收方式**:
- [ ] 类型推断信息正确生成
- [ ] 具体类型可确定时生成直接调用 IR
- [ ] 类型不确定时生成 vtable 调用 IR

**相关测试**:
| 测试名称 | 测试代码 | 预期结果 |
|----------|----------|----------|
| 具体类型直接调用 | `d: Drawable = Circle(1); d.draw()` | 零开销 |
| 未知类型 vtable | `d: Drawable = get_shape(); d.draw()` | vtable 调用 |

---

### 阶段 5：集成测试

#### 5.1.1 功能测试

| 测试名称 | 测试代码 | 预期结果 |
|----------|----------|----------|
| 基本接口赋值 | `d: Drawable = Circle(1); d.draw(screen)` | ✅ 工作 |
| 接口列表 | `shapes: List[Drawable] = [c, r]` | ✅ 工作 |
| 接口作为函数参数 | `fn process(d: Drawable) { d.draw() }` | ✅ 工作 |
| 运行时多态 | `fn handle(d: Drawable) = d.draw()` | ✅ vtable 调用 |

#### 5.1.2 回归测试

| 测试名称 | 测试目标 |
|----------|----------|
| 泛型约束继续工作 | `[T: Drawable](item: T)` 正常工作 |
| 现有代码不破坏 | 所有现有测试通过 |

---

## 三、详细实施步骤

### 步骤 1：更新设计文档

**文件**: `docs/src/reference/plan/completed/constraint-design.md`

**修改清单**:

| 位置 | 修改内容 |
|------|----------|
| 限制性规定 | 移除"约束只能在泛型上下文中使用" |
| 错误定义 | 移除 "Constraint can only be used in generic context" 错误 |
| 验收标准 | 更新为"被正确处理"而非"被拒绝" |
| 新增章节 | 添加"编译期优化策略"章节 |

**新增章节内容**:

```markdown
### 六、编译期优化策略

#### 6.1 零开销接口调用

当接口赋值的右值是具体类型且可确定时，编译器优化为零开销调用：

```yaoxiang
# 源代码
d: Drawable = Circle(1)
d.draw(screen)

# 编译后（优化版）
# Circle 是具体类型，直接调用 Circle.draw
circle_draw(screen)  # 零开销，无 vtable
```

#### 6.2 推断规则

| 场景 | 推断结果 | 调用方式 |
|------|----------|----------|
| 直接赋值具体类型 | 具体类型 Circle | 直接调用 |
| 函数返回值 | 未知 | vtable |
| 异构集合 | 多个类型 | vtable |

#### 6.3 vtable 兜底

当具体类型无法确定时，使用 vtable 机制。

**验收方式**:
- [ ] 文档通过审查
- [ ] 与现有 RFC 无冲突

---

### 步骤 2：修改 assignment.rs

**实现目标**:
- 移除对约束类型的拒绝逻辑
- 允许任何合法的子类型赋值通过

**验收方式**:
- [ ] `d: Drawable = Circle(1)` 不报错
- [ ] `d: Drawable = Point(1, 2)` 报正确的类型错误（缺少方法）

---

### 步骤 3：扩展子类型检查

**实现目标**:
- 在 `is_subtype` 中支持约束类型
- 实现 `satisfies_constraint` 函数检查具体类型是否满足约束

**验收方式**:
- [ ] 具体类型满足约束时返回 true
- [ ] 缺少方法时返回 false
- [ ] 方法签名不兼容时返回 false

---

### 步骤 4：类型推断信息扩展

**实现目标**:
- 新增类型推断信息结构
- 区分 Concrete（具体类型）和 Dynamic（动态类型）

**验收方式**:
- [ ] 推断信息正确生成
- [ ] 推断信息正确传递到 IR

---

### 步骤 5：IR 生成优化

**实现目标**:
- 具体类型生成直接调用 IR
- 动态类型生成虚调用 IR

**验收方式**:
- [ ] 具体类型生成直接调用
- [ ] 未知类型生成虚调用

---

### 步骤 6：后端优化

**实现目标**:
- 直接调用无 vtable 开销
- 虚调用正常工作

**验收方式**:
- [ ] 直接调用无 vtable 开销
- [ ] vtable 调用正常工作

---

## 四、测试计划

### 4.1 单元测试

| 测试文件 | 测试内容 | 数量 |
|----------|----------|------|
| `test_constraint_assignment.rs` | 接口赋值语法 | 10+ |
| `test_subtyping_constraint.rs` | 约束子类型检查 | 15+ |
| `test_inference.rs` | 类型推断优化 | 10+ |

### 4.2 集成测试

| 测试名称 | 测试代码 | 验收标准 |
|----------|----------|----------|
| 接口基本赋值 | `d: Drawable = Circle(1)` | 编译通过 |
| 接口方法调用 | `d.draw(screen)` | 正常工作 |
| 接口列表 | `shapes: List[Drawable] = [c, r, p]` | 正常工作 |
| 泛型约束回退 | `[T: Drawable](item: T)` | 继续工作 |

### 4.3 回归测试

| 测试名称 | 验收标准 |
|----------|----------|
| 现有泛型测试 | 全部通过 |
| 现有接口测试 | 全部通过 |
| 现有子类型测试 | 全部通过 |

---

## 五、风险与缓解

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| 类型推断复杂度 | 可能无法准确推断 | 提供手动注解语法 |
| 回归风险 | 破坏现有功能 | 完整回归测试套件 |

---

## 六、验收标准

### 6.1 功能验收

- [ ] 支持 `d: Drawable = Circle(1)` 语法
- [ ] 支持 `shapes: List[Drawable] = [c, r]` 语法
- [ ] 约束子类型检查正确实现
- [ ] 类型错误信息清晰

### 6.2 回归验收

- [ ] 所有现有测试通过
- [ ] 泛型约束继续正常工作

---

## 七、文件清单

### 7.1 需要修改的文件

| 文件路径 | 说明 |
|----------|------|
| `docs/src/reference/plan/completed/constraint-design.md` | 更新设计决策 |
| `src/frontend/typecheck/checking/assignment.rs` | 移除限制 |
| `src/frontend/typecheck/checking/subtyping.rs` | 添加约束检查 |
| `src/frontend/typecheck/inference_info.rs` | 新增推断信息 |
| `src/middle/core/ir.rs` | 添加直接调用 |
| `src/backends/...` | 后端优化 |

### 7.2 需要新增的测试

| 文件路径 | 说明 |
|----------|------|
| `tests/constraint_assignment_test.rs` | 接口赋值测试 |
| `tests/constraint_subtyping_test.rs` | 约束子类型测试 |
| `tests/constraint_inference_test.rs` | 类型推断测试 |

---

## 八、里程碑

| 阶段 | 目标 | 预计时间 |
|------|------|----------|
| 阶段 1 | 设计文档更新 | 1 天 |
| 阶段 2 | 移除编译器限制 | 1 天 |
| 阶段 3 | 子类型检查实现 | 2 天 |
| 阶段 4 | 类型推断优化 | 3 天 |
| 阶段 5 | 测试与回归 | 2 天 |
| **总计** | | **9 天** |

---

## 九、已确定的设计决策

1. **推断失败时的行为**：回退到 vtable 机制（无需讨论）
2. **手动注解语法**：暂不需要
