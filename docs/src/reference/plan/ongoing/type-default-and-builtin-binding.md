# 类型默认值与内置绑定实现计划

## 概述

本计划实现 YaoXiang 语言的两个新特性：
1. **类型默认值初始化**：类型字段支持默认值，构造时可选提供
2. **内置绑定**：在类型定义体内直接绑定方法（引用外部函数或内联匿名函数）

### 核心数据结构变更

```
类型定义体字段：
├── 字段声明：field: Type
├── 字段默认值：field: Type = expression
├── 外部函数绑定：field = function[position]
└── 内联函数绑定：field: (params) -> Return = { body }
```

### 涉及模块

- 解析器（Parser）：新增语法解析
- 语义分析（Analyzer）：新增类型检查
- 代码生成（Codegen）：新增默认值和绑定处理

---

## 实现步骤

### Phase 1: 解析器增强

#### 1.1 扩展类型字段 AST

**目标**：新增字段类型以区分普通字段、默认值字段、绑定字段

**原子操作**：
1. 在 `ast.rs` 新增 `TypeField` 变体：
   - `Field { name, ty, default }` - 普通/默认值字段
   - `Binding { name, function, positions }` - 外部函数绑定
   - `InlineMethod { name, params, return_ty, body }` - 内联函数绑定

2. 扩展解析器 `parse_type_body_field()` 函数，区分：
   - `field: Type = expression` → 默认值字段
   - `field = function[positions]` → 外部绑定
   - `field: (params) -> Return = { body }` → 内联绑定

**验收方案**：
- [ ] 解析 `Point: Type = { x: Float = 0 }` 生成正确的 AST
- [ ] 解析 `Point: Type = { distance = distance[0] }` 生成 Binding 节点
- [ ] 解析 `Point: Type = { distance: (p: Point) -> Float = {...} }` 生成 InlineMethod 节点

**测试方案**：
- 单元测试：测试各类字段语法解析
- 快照测试：保存解析结果 AST

---

### Phase 2: 语义分析增强

#### 2.1 默认值字段类型检查

**目标**：验证默认值表达式类型与字段类型一致

**原子操作**：
1. 新增 `Analyzer::check_field_default()` 方法
2. 验证 `default.ty` 可赋值给 `field.ty`
3. 在类型体分析时收集默认值信息到 `TypeInfo`

**验收方案**：
- [ ] `x: Float = 0` 通过类型检查
- [ ] `x: Float = "str"` 报错类型不匹配
- [ ] `x: Int = 1.0` 报错（Float 不能赋给 Int）

**测试方案**：
- 错误用例测试：类型不匹配的默认值

#### 2.2 绑定字段语义检查

**目标**：验证绑定引用的函数存在，位置索引有效

**原子操作**：
1. 新增 `Analyzer::check_field_binding()` 方法
2. 验证引用的函数名存在
3. 验证位置索引在函数参数范围内
4. 验证绑定位置的类型与当前类型匹配
5. 生成柯里化后的方法签名

**验收方案**：
- [ ] `distance = distance[0]` 对 `distance: (a: Point, b: Point) -> Float` 验证通过
- [ ] `distance = distance[5]` 对 2 参数函数报错索引越界
- [ ] `distance = distance[0]` 对 `distance: (a: String, b: String)` 报错类型不匹配

**测试方案**：
- 错误用例测试：无效函数引用、无效位置索引、类型不匹配

#### 2.3 内联方法语义检查

**目标**：验证内联方法的参数类型和返回值类型

**原子操作**：
1. 新增 `Analyzer::check_inline_method()` 方法
2. 验证方法体类型与声明的返回类型一致
3. 在方法体内支持 `this` 引用（指向类型实例）
4. 将内联方法添加到类型的 method 表

**验收方案**：
- [ ] 内联方法体类型推导结果与声明返回类型一致
- [ ] 方法体内 `this.x` 可正确解析为字段访问
- [ ] `this` 类型为当前类型

**测试方案**：
- 单元测试：内联方法类型推导

---

### Phase 3: 代码生成增强

#### 3.1 默认值初始化代码生成

**目标**：生成默认构造器和带默认值覆盖的构造器调用

**原子操作**：
1. 新增 `Codegen::generate_default_constructor()` 方法
2. 为每个有默认值的字段生成默认初始化逻辑
3. 为每个无默认值的字段生成必填检查
4. 生成 `Point()` 和 `Point(x=1, y=2)` 的构造调用

**验收方案**：
- [ ] `Point()` 生成调用默认值的代码
- [ ] `Point(x=1)` 只覆盖 x，y 使用默认值
- [ ] `Point(x=1, y=2)` 覆盖所有字段

**测试方案**：
- 集成测试：编译并运行默认值初始化代码

#### 3.2 绑定方法代码生成

**目标**：为外部函数绑定和内联方法生成调用转发

**原子操作**：
1. 新增 `Codegen::generate_binding_call()` 方法
2. 生成方法调用转发到原始函数的代码
3. 处理柯里化：方法参数 + this 参数 = 完整函数参数

**验收方案**：
- [ ] `p1.distance(p2)` 生成调用 `distance(p1, p2)` 的代码
- [ ] 多位置绑定 `Point.transform = transform[0, 1]` 正确转发

**测试方案**：
- 集成测试：编译并运行绑定方法调用

---

### Phase 4: 运行时支持

#### 4.1 默认值表达式求值

**目标**：运行时正确求值默认值表达式

**原子操作**：
1. 在构造器中求值默认值表达式
2. 处理嵌套类型（类型字段的默认值）
3. 处理闭包（默认值可能捕获环境）

**验收方案**：
- [ ] 简单字面量默认值 `0`, `"hello"` 正确求值
- [ ] 表达式默认值 `x: Int = 1 + 2` 正确求值为 3

**测试方案**：
- 运行时测试：验证默认值实际生效

---

## 测试计划

### 单元测试

| 测试类别 | 测试内容 |
|----------|----------|
| 解析测试 | 各类字段语法解析 |
| 类型检查 | 默认值类型匹配 |
| 类型检查 | 绑定位置有效性 |
| 代码生成 | 默认值生成 |

### 集成测试

| 测试用例 | 预期结果 |
|----------|----------|
| `Point: Type = { x: Float = 0, y: Float = 0 }` + `Point()` | 构造成功 |
| `Point: Type = { x: Float, y: Float }` + `Point()` | 编译错误 |
| `Point: Type = { x: Float = 0 } + Point(x=10)` | x=10, y=0 |
| 外部绑定 + 调用 | 方法调用转发正确 |
| 内联绑定 + 调用 | 内联函数执行正确 |

### 回归测试

- 现有类型定义语法不受影响
- 现有绑定语法不受影响
- 现有构造器调用不受影响

---

## 风险与依赖

### 依赖

- RFC-004（柯里化多位置绑定）：内置绑定依赖其位置语法
- RFC-010（统一类型语法）：基于统一语法模型

### 风险

| 风险 | 影响 | 缓解 |
|------|------|------|
| 解析歧义 | `field = value` 可能是赋值或绑定 | 根据 `=` 右侧语法区分 |
| this 引用 | 内联方法中 this 需要特殊处理 | 在 Analyzer 中注入 this 符号 |

---

## 里程碑

1. **M1**: 解析器支持所有字段类型
2. **M2**: 语义检查全部字段规则
3. **M3**: 代码生成支持默认值和绑定
4. **M4**: 集成测试通过
