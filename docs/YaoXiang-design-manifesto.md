# YaoXiang（爻象）设计宣言

> **版本**：v1.1.0
> **状态**：正式发布
> **作者**：晨煦 + YaoXiang 社区
> **日期**：2025-01-03

---

> 「道生一，一生二，二生三，三生万物。」
> —— 《道德经》
>
> 类型如道，万物皆由此生。

---

## 一、为什么创造 YaoXiang？

### 1.1 填补的语言空白

在编程语言的历史长河中，我们见证了无数优秀语言的诞生与演进：C 语言带来了系统编程的效率革命，Python 创造了人人可学的编程体验，Rust 证明了内存安全与性能可以兼得，TypeScript 让大型前端项目变得可维护。然而，当我们审视当今的语言生态时，仍然发现一个明显的断层地带——**没有任何一门语言能够同时满足以下三个核心需求**：

| 需求 | 现有解决方案的问题 |
|------|-------------------|
| **类型安全** | Rust 过于严苛，学习曲线陡峭；TypeScript 是可选类型，无法提供编译时保证 |
| **自然语法** | Rust 语法复杂晦涩；Haskell 函数式门槛过高；传统静态语言冗长繁琐 |
| **AI 友好** | 现有语言语法歧义多、AST 复杂、隐藏行为难以预测，AI 生成和修改代码的准确率受限 |

YaoXiang 的诞生，正是为了填补这一空白。我们相信：**编程语言应该既强大又亲和，既安全又高效，既严谨又优雅**。

### 1.2 解决的实际问题

**问题一：类型系统的碎片化**

当今的编程语言在类型系统上呈现严重的碎片化。静态类型语言追求编译时的绝对正确，但往往以牺牲开发效率为代价；动态类型语言提供了灵活性，却在大型项目中暴露出难以维护的缺陷。YaoXiang 提出「一切皆类型」的统一抽象框架，让类型成为贯穿语言设计的主线，而非事后添加的补丁。

**问题二：内存安全与性能的二选一**

长久以来，开发者不得不在内存安全与运行性能之间做出艰难抉择。GC（垃圾回收）虽然解放了开发者，却带来了延迟波动和内存开销；手动内存管理虽然高效，却如同走钢丝般危险。YaoXiang 采用 Rust 风格的所有权模型，在编译期消除数据竞争和内存泄漏，同时保持零成本抽象，无需 GC 即可实现高性能。

**问题三：异步编程的认知负担**

现代应用离不开网络和并发，而异步编程一直是程序员的噩梦。回调函数嵌套、Promise 链式调用、async/await 语法——每一种方案都增加了代码的复杂性。YaoXiang 重新设计了异步模型：只需在函数签名后添加 `spawn` 标记，编译器自动处理所有异步细节，让并发编程如同同步代码一样自然。

**问题四：AI 辅助编程的瓶颈**

当 AI 开始辅助开发者编写代码时，语言设计的选择变得至关重要。模糊的语法规则、隐式的类型转换、复杂的语法糖——这些人类程序员已经习惯的特性，却成为 AI 理解和生成的障碍。YaoXiang 从设计之初就将「AI 友好」作为核心目标：严格的缩进规则、明确的代码块边界、无歧义的语法结构，让 AI 能够准确理解、生成和修改代码。

### 1.3 语言的哲学根基

YaoXiang 的名字源于《易经》中的「爻」与「象」。「爻」是组成卦象的基本符号，象征着阴阳变化、动静相生；「象」是事物本质的外在表现，代表万象万物、包罗万象。

这一哲学思想体现在语言设计的每一个细节中：

- **统一性**：如同爻卦的简单符号构成复杂卦象，YaoXiang 用少数几个核心概念（类型、函数、构造器）构建完整的编程模型
- **层次性**：如同象有先后天之分，YaoXiang 的类型系统具有清晰的层次结构，从原类型到泛型，从值到元类型
- **变化性**：如同阴阳流转、变化无穷，YaoXiang 支持依赖类型，允许类型随值变化而演化
- **可识别性**：如同卦象可解、万物可象，YaoXiang 提供完整的类型反射能力，运行时类型信息完全可用

---

## 二、核心哲学与原则

以下设计信条是 YaoXiang 的基石，**不可妥协、不可违背**。任何特性提案都必须经过这些原则的检验。

### 2.1 原则一：一切皆类型

在 YaoXiang 的世界观中，类型是最高层的抽象单元，是贯穿语言的核心概念。

**具体体现**：

- **值是类型的实例**：`42` 是 `Int` 类型的实例，`"hello"` 是 `String` 类型的实例
- **类型本身也是类型**：元类型（`type`）是一切类型的类型，`Int` 是 `type` 的实例
- **函数是类型映射**：`fn add(Int, Int) -> Int` 描述了一个从 `Int × Int` 到 `Int` 的类型映射
- **模块是类型组合**：模块是包含函数和类型的命名空间组合

**不可妥协的理由**：统一类型抽象能够简化语言语义，消除值与类型的二元对立，让类型系统成为代码正确性的守护者，而非绊脚石。

### 2.2 原则二：严格结构化

YaoXiang 的语法设计追求「无歧义、可预测、易解析」。

**具体规则**：

- **强制 4 空格缩进**：禁止使用 Tab 字符，代码块边界一目了然
- **括号不可省略**：函数参数必须有括号，列表元素必须有逗号
- **代码块必须有花括号**：`if`、`while`、`for` 等控制流必须使用 `{ }` 包裹
- **关键字数量精简**：仅保留 17 个核心关键字，拒绝语法糖泛滥

**不可妥协的理由**：严格结构化带来三个关键优势——（1）IDE 语法高亮和代码折叠更准确；（2）AI 代码生成和修改的准确率大幅提升；（3）新学习者能够快速理解代码结构。

### 2.3 原则三：零成本抽象

高层次的抽象不应该带来运行时的性能开销。

**具体保证**：

- **单态化**：泛型函数在编译时展开为具体版本，无虚表查找开销
- **内联优化**：简单函数自动内联，消除函数调用开销
- **栈分配优先**：小对象默认栈分配，堆分配仅在必要时使用
- **无 GC**：所有权模型保证内存安全，无需垃圾回收器的运行时开销

**不可妥协的理由**：性能是编程语言的生存底线。任何以性能为代价换取便利性的设计都是对程序员的背叛。

### 2.4 原则四：默认不可变

可变性与复杂性如影随形。YaoXiang 选择默认不可变，让代码更易于推理和理解。

**具体规则**：

- 变量默认不可变，赋值后不能再修改
- 需要可变时必须显式声明 `mut`
- 引用默认不可变，可变引用需要 `mut` 标记
- 所有权的转移意味着原绑定失效

**不可妥协的理由**：不可变性是并发安全的基础，是代码可读性的保障，是函数式编程智慧的结晶。

### 2.5 原则五：类型即数据

类型信息不应仅存在于编译期，而应在运行时完全可用。

**具体能力**：

- 运行时类型查询：任何值都可以获取其类型信息
- 类型反射：可以构造和操作类型本身
- 模式匹配解构：类型构造器可直接用于模式匹配
- 泛型特化：运行时可以获取泛型参数的具现化类型

**不可妥协的理由**：完整的类型反射能力是元编程的基础，是高性能框架和工具的基石。

---

## 三、关键创新与特性

YaoXiang 在吸收现有语言优秀特性的同时，提出了以下创新性设计。

### 3.1 创新一：统一类型语法

**传统语言的类型定义**往往需要多个关键字：

```rust
// Rust
struct Point { x: f64, y: f64 }
enum Result<T, E> { Ok(T), Err(E) }
enum Color { Red, Green, Blue }
union IntOrFloat { i: i32, f: f32 }
```

**YaoXiang 的统一语法**：只有构造器，没有 `enum`、`struct`、`union` 关键字。规则简单——用 `|` 分隔的都是构造器，构造器名(参数) 就是类型。

```yaoxiang
# 单构造器（结构体风格）
type Point = Point(x: Float, y: Float)

# 多构造器（联合风格）
type Result[T, E] = ok(T) | err(E)

# 零参构造器（枚举风格）
type Color = red | green | blue

# 混合构造器
type Shape = circle(Float) | rect(Float, Float)
```

**创新价值**：消除了类型定义的关键字碎片，让类型系统更统一、更简洁。

### 3.2 创新二：构造器即类型

**值构造与函数调用完全相同**：

```yaoxiang
# 类型定义
type Point = Point(x: Float, y: Float)
type Result[T, E] = ok(T) | err(E)

# 值构造：与函数调用语法完全相同
p: Point = Point(3.0, 4.0)
r: Result[Int, String] = ok(42)
err_msg: Result[Int, String] = err("not found")
c: Color = green
```

**创新价值**：消除了「类型」与「值」之间的认知鸿沟，学习成本更低，代码更一致。

### 3.3 创新三：柯里化方法绑定

YaoXiang 采用纯函数式设计，通过柯里化实现类似对象方法调用的语法糖，无需引入 `class` 和 `method` 关键字。

```yaoxiang
# === Point.yx ===

# 统一语法：构造器就是类型
type Point = Point(x: Float, y: Float)

# 核心函数：欧几里得距离（第一个参数是操作的主体）
distance(Point, Point) -> Float = (a, b) => {
    dx = a.x - b.x
    dy = a.y - b.y
    (dx * dx + dy * dy).sqrt()
}

# 方法语法糖绑定
Point.distance(_) = distance(self, _)
```

```yaoxiang
# === main.yx ===

use Point

main() -> Void = () => {
    p1 = Point(3.0, 4.0)
    p2 = Point(1.0, 2.0)

    # 两种调用方式完全等价
    d1 = distance(p1, p2)      # 直接调用核心函数
    d2 = p1.distance(p2)       # 方法语法糖

    # 函数式用法：预先绑定第一个参数
    dist_from_origin = Point.distance(Point(0.0, 0.0))
    result = dist_from_origin(p1)   # 5.0

    # 柯里化用法：延迟求值
    get_dist_to_p2 = p2.distance(_)
    d3 = get_dist_to_p2(p1)         # 2.828
}
```

**创新价值**：纯函数式设计，无隐藏的 `self` 参数，函数即值可以自由传递和组合。

### 3.4 创新四：并作模型

> 「万物并作，吾以观复。」——《易·复卦》
>
> 并作模型取意于此，描述了一种编程范式：开发者以同步、顺序的思维描述逻辑，而语言运行时令其中的计算单元如万物并作般自动、高效地并发执行，并在最终统一协同。

**核心三原则**：

| 原则 | 说明 |
|------|------|
| **同步语法** | 所见即所得的顺序代码 |
| **并发本质** | 运行时自动提取并行性 |
| **统一协同** | 结果在需要时自动汇聚，保证逻辑正确 |

**术语体系**：

| 官方术语 | 对应语法 | 阐释 |
|----------|----------|------|
| **并作函数** | `spawn fn` | 定义可参与并作执行的计算单元 |
| **并作块** | `spawn { a(), b() } | 显式声明的并发疆域，块内任务并作执行 |
| **并作循环** | `spawn for x in xs { ... } | 数据并行，循环体在所有元素上并作执行 |
| **并作值** | `Async[T]` | 正在并作中的未来值，使用时自动等待 |
| **并作图** | 惰性计算图(DAG) | 并作发生的舞台，描述依赖与并行关系 |
| **并作调度器** | 运行时任务调度器 | 协调万物，让它们在正确时机并作的智能中枢 |

```yaoxiang
# === 并作函数 ===
# spawn 标记的函数返回 Async[T]，语法与普通函数一致
fetch_data(String) -> JSON spawn = (url) => {
    HTTP.get(url).json()
}

# === 并作块 ===
# spawn { } 内的表达式强制并行执行
compute_all() -> (Int, Int, Int) spawn = () => {
    (a, b, c) = spawn {
        heavy_calc(1),    # 任务 1
        heavy_calc(2),    # 任务 2
        another_calc(3)   # 任务 3
    }
    (a, b, c)
}

# === 并作循环 ===
# spawn for 标记的循环自动并行化
parallel_sum(Int) -> Int spawn = (n) => {
    total = spawn for i in 0..n {
        fibonacci(i)  # 每次迭代并行执行
    }
    total
}

# === 自动等待 ===
main() -> Void = () => {
    # 两个独立请求自动并行执行
    users = fetch_data("https://api.example.com/users")
    posts = fetch_data("https://api.example.com/posts")

    # 等待点在需要结果时自动插入
    print(users.length + posts.length)  # 自动等待 users 和 posts
}
```

**线程安全**：

```yaoxiang
# Send/Sync 约束保证编译时线程安全
type SafeCounter = SafeCounter(mutex: Mutex[Int])

main() -> Void = () => {
    counter: Arc[SafeCounter] = Arc.new(SafeCounter(Mutex.new(0)))

    # spawn 自动检查 Send 约束
    spawn(|| => {
        guard = counter.mutex.lock()
        guard.value = guard.value + 1
    })
}
```

**技术文档**：
- 详见 [《并作模型白皮书》](YaoXiang-async-whitepaper.md)
- 详见 [异步实现方案](YaoXiang-async-implementation.md)
- 详见 [线程安全设计](works/plans/async/yaoxiang-threading-safety-design.md)

**创新价值**：异步编程的认知负担降为零，代码可读性与同步代码完全相同，同时获得高性能并行的执行效率。

### 3.5 创新五：依赖类型支持

类型可以依赖于值，实现真正的类型驱动开发。

```yaoxiang
# 固定长度向量
type Vector[T, n: Nat] = {
    data: [T; n]
    length: n
}

# 使用
vec: Vector[Int, 3] = Vector([1, 2, 3], 3)

# 类型检查
# vec: Vector[Int, 3] = Vector([1, 2], 2)  # 编译错误！长度不匹配
```

**创新价值**：在编译期捕获更多错误，实现更精确的类型保证。

### 3.6 创新六：极简关键字设计

YaoXiang 仅定义 17 个核心关键字，数量远少于主流语言：

```
type   pub    use    spawn
ref    mut    if     elif
else   match  while  for    return
break  continue as     in
```

| 对比语言 | 关键字数量 |
|----------|-----------|
| YaoXiang | **17** |
| Rust | 51+ |
| Python | 35 |
| TypeScript | 64+ |
| Go | 25 |

**创新价值**：更低的记忆负担，更一致的语法风格，更易解析的语法结构。

---

## 四、初步语法预览

以下代码示例展示 YaoXiang 的语言风貌，帮助您快速感受其设计美学。

### 4.1 Hello World

```yaoxiang
# hello.yx
use std.io

main() -> Void = () => {
    println("Hello, YaoXiang!")
}
```

### 4.2 类型定义与函数

```yaoxiang
# 统一类型语法
type Point = Point(x: Float, y: Float)
type Result[T, E] = ok(T) | err(E)
type Color = red | green | blue

# 函数定义（箭头函数语法）
add(Int, Int) -> Int = (a, b) => a + b

# 泛型函数
identity<T>(T) -> T = (x) => x

# 多行函数
fact(Int) -> Int = (n) => {
    if n == 0 { 1 } else { n * fact(n - 1) }
}
```

### 4.3 模式匹配

```yaoxiang
# 强大的模式匹配
classify(Int) -> String = (n) => {
    match n {
        0 -> "zero"
        1 -> "one"
        _ if n < 0 -> "negative"
        _ -> "positive"
    }
}

# 解构模式
type Point = Point(x: Float, y: Float)
match point {
    Point(0.0, 0.0) -> "origin"
    Point(x, y) -> "point at (" + x + ", " + y + ")"
}
```

### 4.4 列表推导式

```yaoxiang
# Python 风格的列表推导
evens = [x * 2 for x in 0..10]          # [0, 4, 8, 12, 16]
squares = [x * x for x in 1..10 if x % 2 == 1]  # [1, 9, 25, 49, 81]

# 嵌套推导式
matrix = [[i * j for j in 1..4] for i in 1..3]
# [[1, 2, 3], [2, 4, 6], [3, 6, 9]]
```

### 4.5 所有权与借用

```yaoxiang
# 默认不可变引用
process(ref Data) -> Void = (data) => {
    # data 是只读的
}

# 可变引用
modify(mut Data) -> Void = (data) => {
    # 可以修改 data
}

# 转移所有权
consume(Data) -> Void = (data) => {
    # data 的所有权转移进来
}
```

### 4.6 错误处理

```yaoxiang
# Result 类型
type Result[T, E] = ok(T) | err(E)

fn divide(Float, Float) -> Result[Float, String] = (a, b) => {
    if b == 0.0 {
        err("Division by zero")
    } else {
        ok(a / b)
    }
}

# 使用 ? 运算符
process() -> Result[Int, String] = () => {
    a = read_number()?
    b = read_number()?
    c = divide(a, b)?
    ok(c * 2)
}
```

### 4.7 并发编程（SeamlessAsync）

```yaoxiang
# spawn 标记异步函数
fetch_api(String) -> JSON spawn = (url) => {
    response = HTTP.get(url)
    JSON.parse(response.body)
}

# 并发构造块：显式并行
process_all() -> (JSON, JSON, JSON) spawn = () => {
    (a, b, c) = spawn {
        fetch_api("https://api1.com/data"),
        fetch_api("https://api2.com/data"),
        fetch_api("https://api3.com/data")
    }
    (a, b, c)
}

# 数据并行循环
parallel_process(Int) -> Int spawn = (n) => {
    total = spawn for i in 0..n {
        compute(i)
    }
    total
}

# 线程安全示例
type ThreadSafeCounter = ThreadSafeCounter(value: Mutex[Int])

main() -> Void = () => {
    counter: Arc[ThreadSafeCounter] = Arc.new(ThreadSafeCounter(Mutex.new(0)))

    # 自动并行执行
    spawn(|| => counter.value.lock().value = counter.value.lock().value + 1)
    spawn(|| => counter.value.lock().value = counter.value.lock().value + 2)
}
```

---

## 五、路线图与待定项

### 5.1 已决定的设计决策

以下决策已经过充分讨论和审阅，**不再接受更改**：

| 模块 | 决策 | 说明 |
|------|------|------|
| **类型系统** | 一切皆类型 | 值、函数、模块、泛型都是类型 |
| **类型语法** | 统一构造器语法 | 无 `enum`、`struct`、`union` 关键字 |
| **缩进规则** | 4空格缩进 | 强制要求，禁止 Tab |
| **关键字** | 17个核心关键字 | 如上表所列 |
| **函数语法** | 箭头函数语法 | `fn_name(Type1, Type2) -> Type = (params) => body` |
| **方法绑定** | 柯里化实现 | `Type.method(_) = func(self, _)` |
| **异步模型** | 并作模型 | 并作模型，惰性求值，自动并行 |
| **内存管理** | 所有权模型 | 无 GC，编译期安全保证 |
| **文件即模块** | 模块系统 | 每个 `.yx` 文件是一个模块 |
| **主函数** | `main() -> Void` | 程序入口点 |
| **线程安全** | Send/Sync 约束 | 编译时消除数据竞争 |

### 5.2 待讨论的设计议题

以下议题仍在讨论中，**欢迎社区贡献意见**：

| 议题 | 当前状态 | 开放问题 |
|------|----------|----------|
| **字面量语法** | 浮点数支持 | 是否支持 `3.14e-10` 科学计数法？ |
| **泛型推导** | 基础支持 | 是否支持返回类型泛型推导？ |
| **模式匹配** | 基础支持 | 是否支持视图模式（view patterns）？ |
| **宏系统** | 尚未设计 | 是否需要卫生宏？语法设计方向？ |
| **包管理器** | 尚未设计 | 是否需要集中式包仓库？依赖解析策略？ |
| **FFI** | 尚未设计 | 与 C 互操作的具体方案？ |
| **泛型约束** | 基础支持 | 是否支持 trait/bounds 机制？ |
| **反射深度** | 基础支持 | 是否支持访问私有成员？ |

### 5.3 实现路线图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              YaoXiang 实现路线图                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  v0.1: Rust 解释器 ────────→ v0.5: Rust 编译器 ────────→ v1.0: Rust AOT    │
│        ✅ 已完成                    │ (当前阶段)               编译器          │
│                                      │                                      │
│                                      ▼                                      │
│  v0.6: YaoXiang 解释器 ←─────── v1.0: YaoXiang JIT 编译器 ←──── v2.0:      │
│        （自举）                     （自举）                      YaoXiang AOT │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

**里程碑详情**：

| 版本 | 状态 | 目标 | 交付物 |
|------|------|------|--------|
| **v0.1** | ✅ 完成 | 解释器原型 | 基本解释器、词法分析、语法分析、基础类型 |
| **v0.2** | ✅ 完成 | 完整解释器 | 类型检查、模式匹配、模块系统 |
| **v0.3** | 🔄 进行中 | 字节码生成 | IR 中间表示、字节码生成、闭包优化 |
| **v0.4** | 🔄 进行中 | 字节码虚拟机 | VM 核心、指令执行、调用帧管理 |
| **v0.5** | ⏳ 待开始 | 运行时系统 | GC、调度器、标准库 IO |
| **v1.0** | ⏳ 待开始 | AOT 编译器 | 完整优化、本地代码生成 |
| **v2.0** | ⏳ 待开始 | 自举编译器 | 用 YaoXiang 编写的新编译器 |

### 5.4 当前实现状态

| 模块 | 状态 | 完成度 | 说明 |
|------|------|--------|------|
| **词法分析器** | ✅ 完成 | 100% | Token 定义、关键字识别、测试用例 |
| **语法分析器** | ✅ 完成 | 100% | AST 定义、表达式/语句解析、边界测试 |
| **类型检查器** | ✅ 完成 | 95% | 类型推断、单态化、泛型特化、错误处理 |
| **IR 中间表示** | ✅ 完成 | 90% | IR 指令定义、类型表示、控制流图 |
| **字节码生成** | ✅ 完成 | 85% | 表达式/语句/控制流字节码、闭包转换 |
| **字节码虚拟机** | ✅ 完成 | 80% | VM 核心、指令执行、调用帧、内联缓存 |
| **运行时调度器** | 🔄 进行中 | 60% | 任务描述符、工作窃取队列、等待队列 |
| **运行时内存** | 🔄 进行中 | 50% | 内存分配器、GC 框架 |
| **标准库** | 🔄 进行中 | 30% | IO、String、List、Dict、Math、Concurrent |
| **JIT 编译器** | ⏳ 待开始 | 0% | 待集成 Cranelift/LLVM |
| **AOT 编译器** | ⏳ 待开始 | 0% | 待实现 |

**代码生成模块详情**：

| 子模块 | 状态 | 关键特性 |
|--------|------|----------|
| 表达式生成 | ✅ 完成 | 算术、比较、逻辑、函数调用 |
| 语句生成 | ✅ 完成 | 赋值、返回、条件、循环 |
| 控制流生成 | ✅ 完成 | Switch 模式匹配、循环展开 |
| 闭包处理 | ✅ 完成 | 环境捕获、闭包转换 |
| 字节码序列化 | ✅ 完成 | 字节码读写、测试用例 |
| 集成测试 | ✅ 完成 | 端到端编译执行测试 |

**异步实现状态（并作模型）**：

| 子模块 | 状态 | 说明 |
|--------|------|------|
| spawn 关键字解析 | ✅ 完成 | 词法/语法分析支持 |
| is_async 标志 | ✅ 完成 | AST/类型系统支持 |
| Async[T] 类型设计 | ✅ 完成 | 设计文档完成 |
| 调度器框架 | ✅ 完成 | 基础工作窃取实现 |
| Send/Sync 约束 | ✅ 完成 | 类型约束设计文档 |
| IR 扩展 | 🔄 进行中 | CallAsync 指令已定义 |
| VM 异步指令 | 🔄 进行中 | 指令框架已定义 |
| 完整实现 | ⏳ 待开始 | v0.5 里程碑 |

---

## 六、如何参与贡献

YaoXiang 是一门诞生于社区、成长于社区、服务于社区的语言。我们诚挚邀请每一位热爱编程语言设计的开发者加入这场探索之旅。

### 6.1 设计讨论

**适合人群**：编程语言理论研究者、类型系统爱好者、语言设计狂热者

**参与方式**：

- **GitHub Discussions**：参与「Language Design」分类的讨论
- **设计提案（RFC）**：提出新特性的设计文档，遵循 `rfcs/` 目录下的模板
- **语法评审**：对现有语法设计提出改进建议或发现潜在问题

**当前热门议题**：

- 宏系统的设计与实现
- 泛型 trait/bounds 机制
- 错误处理语法优化
- 标准库 API 设计

**提交设计提案**：

1. 在 `rfcs/` 目录创建新文件
2. 填写 RFC 模板（动机、详细设计、优缺点分析、替代方案）
3. 发起 Pull Request 进行社区评审
4. 经过核心团队审议后合并或拒绝

### 6.2 编译器实现

**适合人群**：编译器开发者、系统程序员、性能优化专家

**当前实现重点**（按优先级排序）：

| 优先级 | 模块 | 说明 | 难度 |
|--------|------|------|------|
| P0 | **字节码虚拟机** | VM 指令完善、性能优化 | 中 |
| P0 | **运行时内存** | GC 实现、内存分配器 | 高 |
| P0 | **异步运行时** | 并作模型完整实现 | 高 |
| P1 | 标准库 | IO、String、List、Concurrent | 中 |
| P1 | JIT 编译器 | Cranelift 集成 | 高 |
| P2 | AOT 编译器 | LLVM/ Cranelift 后端 | 高 |
| P3 | 自举编译器 | 用 YaoXiang 重写 | 极高 |

**技术栈**：

- **实现语言**：Rust（当前阶段）
- **代码生成**：Cranelift 或 LLVM
- **构建工具**：Cargo
- **测试框架**：Rust `#[test]` + `cargo nextest`

**开始贡献**：

1. 查看 `docs/YaoXiang-implementation-plan.md` 了解架构设计
2. 选择 `src/` 目录下感兴趣的模块
3. 查看 `tests/unit/` 了解测试要求
4. 提交代码前确保 `cargo fmt` 和 `cargo clippy` 通过

### 6.3 工具链开发

**适合人群**：IDE 插件开发者、工具链爱好者、效率工具追求者

**需要开发的工具**：

| 工具 | 状态 | 说明 |
|------|------|------|
| **LSP 服务器** | ⏳ 待开始 | 语言服务器协议支持 |
| **调试器集成** | ⏳ 待开始 | GDB/LLDB 集成 |
| **格式化工具** | ⏳ 待开始 | `yaoxiang fmt` |
| **包管理器** | ⏳ 待开始 | 依赖管理、版本解析 |
| **包仓库** | ⏳ 待开始 | 中央仓库或去中心化 |
| **REPL** | ⏳ 待开始 | 交互式解释器 |
| **基准测试工具** | ⏳ 待开始 | 性能分析 |
| **VS Code 插件** | ⏳ 待开始 | 语法高亮、补全、调试 |
| **Vim/Neovim 插件** | ⏳ 待开始 | 语法高亮、LSP 客户端 |

**项目结构参考**：

```
yaoxiang/
├── src/
│   ├── tools/                    # 工具链
│   │   ├── lsp/                  # LSP 服务器
│   │   ├── fmt/                  # 格式化工具
│   │   ├── repl/                 # REPL
│   │   └── benchmark/            # 基准测试
│   └── ...
├── extensions/                   # 编辑器扩展
│   ├── vscode/                   # VS Code
│   └── vim/                      # Vim/Neovim
```

### 6.4 标准库建设

**适合人群**：库开发者、API 设计者、领域专家

**标准库模块规划**：

| 模块 | 优先级 | 说明 |
|------|--------|------|
| `std.io` | P0 | 文件 IO、控制台输入输出 |
| `std.string` | P0 | 字符串操作、格式化 |
| `std.list` | P0 | 列表/数组操作 |
| `std.dict` | P0 | 字典/哈希表 |
| `std.math` | P0 | 数学函数、常量 |
| `std.time` | P1 | 时间日期操作 |
| `std.net` | P1 | 网络编程、HTTP |
| `std.concurrent` | P1 | 并发原语、通道 |
| `std.crypto` | P2 | 加密哈希、签名 |
| `std.json` | P1 | JSON 解析/生成 |
| `std.regex` | P2 | 正则表达式 |
| `std.database` | P3 | 数据库连接 |
| `std.gui` | P3 | 图形界面（长期） |

**设计原则**：

- 一致性：相同功能的函数命名和行为保持一致
- 简洁性：API 应当直观易用，避免过度设计
- 性能：标准库函数应当高效，避免不必要的拷贝
- 可测试：每个函数都应有对应的单元测试

### 6.5 文档与教程

**适合人群**：技术写作者、教育工作者、社区经理

**需要贡献的文档**：

| 文档 | 状态 | 说明 |
|------|------|------|
| 快速入门 | ✅ 完成 | 5 分钟上手指南 |
| 语言指南 | ✅ 完成 | 系统学习核心概念 |
| 语言规范 | ✅ 完成 | 完整的语法和语义定义 |
| 实现计划 | ✅ 完成 | 编译器实现技术细节 |
| API 文档 | ⏳ 待开始 | 标准库 API 参考 |
| 教程 | ⏳ 待开始 | 进阶教程和最佳实践 |
| 博客 | ⏳ 待开始 | 技术文章和设计故事 |
| 翻译 | ⏳ 待开始 | 多语言支持 |

### 6.6 社区建设

**适合人群**：社区经理、活动组织者、布道师

**社区活动**：

- 定期线上 Meetup（每月一次）
- 设计与实现讨论会（每周一次）
- 代码贡献 Sprint（每季度一次）
- 线下聚会和 conference 演讲

**传播渠道**：

- GitHub Discussions：技术讨论
- GitHub Issues：问题报告和功能请求
- Discord/Slack：实时交流
- Twitter/X：项目动态
- 博客：深度文章

### 6.7 贡献指南

**如何开始贡献**：

1. **了解项目**：阅读 README 和设计文档
2. **选择方向**：根据兴趣选择贡献领域
3. **搭建环境**：Rust 1.75+、cargo、git
4. **找任务**：查看 GitHub Issues 的 `good first issue` 标签
5. **提交 PR**：遵循提交规范，编写测试
6. **参与评审**：review 他人的代码，参与讨论

**提交规范**：

```bash
# 提交信息格式
<type>(<scope>): <subject>

# 类型
feat: 新功能
fix: Bug 修复
docs: 文档更新
style: 代码格式（不影响功能）
refactor: 重构
perf: 性能优化
test: 测试
chore: 构建工具或辅助工具

# 示例
feat(typecheck): add generic type inference
fix(parser): fix infinite loop on invalid input
docs(readme): update installation instructions
```

**代码风格**：

- 遵循 `rustfmt.toml` 规范
- 确保 `cargo clippy` 无警告
- 编写必要的单元测试
- 更新相关文档

---

## 附录A：语言速查

### A.1 关键字

| 关键字 | 作用 |
|--------|------|
| `type` | 类型定义 |
| `pub` | 公共导出 |
| `use` | 导入模块 |
| `spawn` | 异步标记（函数/块/循环） |
| `ref` | 不可变引用 |
| `mut` | 可变引用 |
| `if/elif/else` | 条件分支 |
| `match` | 模式匹配 |
| `while/for` | 循环 |
| `return/break/continue` | 控制流 |
| `as` | 类型转换 |
| `in` | 成员检测/列表推导 |

### A.2 注解

| 注解 | 作用 |
|------|------|
| `@blocking` | 标记阻塞操作，分配到阻塞线程池 |
| `@eager` | 标记需急切求值的表达式 |
| `@Send` | 显式声明满足 Send 约束 |
| `@Sync` | 显式声明满足 Sync 约束 |

### A.3 原类型

| 类型 | 描述 | 默认大小 |
|------|------|----------|
| `Void` | 空值 | 0 字节 |
| `Bool` | 布尔值 | 1 字节 |
| `Int` | 有符号整数 | 8 字节 |
| `Uint` | 无符号整数 | 8 字节 |
| `Float` | 浮点数 | 8 字节 |
| `String` | UTF-8 字符串 | 可变 |
| `Char` | Unicode 字符 | 4 字节 |
| `Bytes` | 原始字节 | 可变 |

### A.4 运算符优先级

| 优先级 | 运算符 | 结合性 |
|--------|--------|--------|
| 1 | `()` `[]` `.` | 左到右 |
| 2 | `as` | 左到右 |
| 3 | `*` `/` `%` | 左到右 |
| 4 | `+` `-` | 左到右 |
| 5 | `<<` `>>` | 左到右 |
| 6 | `&` `\|` `^` | 左到右 |
| 7 | `==` `!=` `<` `>` `<=` `>=` | 左到右 |
| 8 | `not` | 右到左 |
| 9 | `and` `or` | 左到右 |
| 10 | `if...else` | 右到左 |
| 11 | `=` `+=` `-=` `*=` `/=` | 右到左 |

---

## 附录B：设计灵感

YaoXiang 的设计借鉴了以下语言和项目的优秀思想：

| 来源 | 借鉴点 |
|------|--------|
| **Rust** | 所有权模型、零成本抽象、类型系统 |
| **Python** | 语法风格、可读性、列表推导 |
| **Idris/Agda** | 依赖类型、类型驱动开发 |
| **TypeScript** | 类型注解、运行时类型 |
| **MoonBit** | AI 友好设计、简洁语法 |
| **Haskell** | 纯函数式、模式匹配 |
| **OCaml** | 类型推断、变体类型 |

---

## 附录C：常见问题

**Q: YaoXiang 与 Rust 相比有什么优势？**

A: YaoXiang 保留了 Rust 的内存安全和零成本抽象，但采用更简单的语法和更低的认知负担。**并作模型**比 Rust 的 `async/await` 更简洁——只需一个 `spawn` 标记，无需手动管理 Future 和 Pin。「万物并作，吾以观复」，让并发编程如同描述自然规律般直观。Send/Sync 约束提供同等的线程安全保证。统一类型语法消除了 `enum`/`struct`/`union` 的概念碎片。

**Q: YaoXiang 适合做什么类型的开发？**

A: 系统编程、应用开发、Web 服务、脚本工具、AI 辅助编程。目标是成为一门通用编程语言。

**Q: 为什么选择 4 空格缩进？**

A: 4 空格提供了清晰的代码块视觉分隔，减少了嵌套深度带来的混淆。这是经过深思熟虑的「AI 友好」设计决策。

**Q: 什么时候会发布 1.0 版本？**

A: 预计在项目启动后 14-18 个月发布 v1.0，具体取决于社区贡献进度。

**Q: 如何联系核心团队？**

A: 通过 GitHub Discussions 或 Discord 社区频道。核心团队成员会定期回复。

---

> **最后更新**：2025-01-03
>
> **文档版本**：v1.1.0
>
> **许可证**：[MIT](LICENSE)

---

> 「爻象变化，万物生焉。类型演化，程序成焉。」
>
> 愿 YaoXiang 的设计之旅，与您同行。
